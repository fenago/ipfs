(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;

  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  for (var i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

},{}],2:[function(require,module,exports){
'use strict';

module.exports = bindexOf;

function bindexOf(buffer, search, offset) {
  offset = offset || 0;

  if (search.length + offset > buffer.length) {
    return -1;
  }

  var x = 0;
  var f = -1;

  for (; offset < buffer.length; offset++) {
    if (buffer[offset] === search[x]) {
      if (!~f) {
        f = offset;
      }
      if (++x === search.length) {
        break;
      }
    } else {
      f = -1;
      x = 0;
    }
  }

  return f;
}

},{}],3:[function(require,module,exports){
(function (Buffer){
'use strict';

/* global Blob, FileReader */

module.exports = function blobToBuffer(blob, cb) {
  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
    throw new Error('first argument must be a Blob');
  }
  if (typeof cb !== 'function') {
    throw new Error('second argument must be a function');
  }

  var reader = new FileReader();

  function onLoadEnd(e) {
    reader.removeEventListener('loadend', onLoadEnd, false);
    if (e.error) cb(e.error);else cb(null, Buffer.from(reader.result));
  }

  reader.addEventListener('loadend', onLoadEnd, false);
  reader.readAsArrayBuffer(blob);
};

}).call(this,require("buffer").Buffer)
},{"buffer":6}],4:[function(require,module,exports){
"use strict";

},{}],5:[function(require,module,exports){
"use strict";

},{}],6:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":1,"ieee754":22}],7:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var keys = require('object-keys');
var foreach = require('foreach');
var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol()) === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function isFunction(fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function arePropertyDescriptorsSupported() {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
		/* eslint-disable no-unused-vars, no-restricted-syntax */
		for (var _ in obj) {
			return false;
		}
		/* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	} catch (e) {
		/* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function defineProperty(object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function defineProperties(object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = props.concat(Object.getOwnPropertySymbols(map));
	}
	foreach(props, function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"foreach":18,"object-keys":8}],8:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$applicationCache: true,
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":9}],9:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],10:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

var _tmatch = require('tmatch');

var _tmatch2 = _interopRequireDefault(_tmatch);

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _SpyUtils = require('./SpyUtils');

var _TestUtils = require('./TestUtils');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * An Expectation is a wrapper around an assertion that allows it to be written
 * in a more natural style, without the need to remember the order of arguments.
 * This helps prevent you from making mistakes when writing tests.
 */

var Expectation = function () {
  function Expectation(actual) {
    _classCallCheck(this, Expectation);

    this.actual = actual;

    if ((0, _TestUtils.isFunction)(actual)) {
      this.context = null;
      this.args = [];
    }
  }

  _createClass(Expectation, [{
    key: 'toExist',
    value: function toExist(message) {
      (0, _assert2.default)(this.actual, message || 'Expected %s to exist', this.actual);

      return this;
    }
  }, {
    key: 'toNotExist',
    value: function toNotExist(message) {
      (0, _assert2.default)(!this.actual, message || 'Expected %s to not exist', this.actual);

      return this;
    }
  }, {
    key: 'toBe',
    value: function toBe(value, message) {
      (0, _assert2.default)(this.actual === value, message || 'Expected %s to be %s', this.actual, value);

      return this;
    }
  }, {
    key: 'toNotBe',
    value: function toNotBe(value, message) {
      (0, _assert2.default)(this.actual !== value, message || 'Expected %s to not be %s', this.actual, value);

      return this;
    }
  }, {
    key: 'toEqual',
    value: function toEqual(value, message) {
      try {
        (0, _assert2.default)((0, _TestUtils.isEqual)(this.actual, value), message || 'Expected %s to equal %s', this.actual, value);
      } catch (error) {
        // These attributes are consumed by Mocha to produce a diff output.
        error.actual = this.actual;
        error.expected = value;
        error.showDiff = true;
        throw error;
      }

      return this;
    }
  }, {
    key: 'toNotEqual',
    value: function toNotEqual(value, message) {
      (0, _assert2.default)(!(0, _TestUtils.isEqual)(this.actual, value), message || 'Expected %s to not equal %s', this.actual, value);

      return this;
    }
  }, {
    key: 'toThrow',
    value: function toThrow(value, message) {
      (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The "actual" argument in expect(actual).toThrow() must be a function, %s was given', this.actual);

      (0, _assert2.default)((0, _TestUtils.functionThrows)(this.actual, this.context, this.args, value), message || 'Expected %s to throw %s', this.actual, value || 'an error');

      return this;
    }
  }, {
    key: 'toNotThrow',
    value: function toNotThrow(value, message) {
      (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The "actual" argument in expect(actual).toNotThrow() must be a function, %s was given', this.actual);

      (0, _assert2.default)(!(0, _TestUtils.functionThrows)(this.actual, this.context, this.args, value), message || 'Expected %s to not throw %s', this.actual, value || 'an error');

      return this;
    }
  }, {
    key: 'toBeA',
    value: function toBeA(value, message) {
      (0, _assert2.default)((0, _TestUtils.isFunction)(value) || typeof value === 'string', 'The "value" argument in toBeA(value) must be a function or a string');

      (0, _assert2.default)((0, _TestUtils.isA)(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);

      return this;
    }
  }, {
    key: 'toNotBeA',
    value: function toNotBeA(value, message) {
      (0, _assert2.default)((0, _TestUtils.isFunction)(value) || typeof value === 'string', 'The "value" argument in toNotBeA(value) must be a function or a string');

      (0, _assert2.default)(!(0, _TestUtils.isA)(this.actual, value), message || 'Expected %s to not be a %s', this.actual, value);

      return this;
    }
  }, {
    key: 'toMatch',
    value: function toMatch(pattern, message) {
      (0, _assert2.default)((0, _tmatch2.default)(this.actual, pattern), message || 'Expected %s to match %s', this.actual, pattern);

      return this;
    }
  }, {
    key: 'toNotMatch',
    value: function toNotMatch(pattern, message) {
      (0, _assert2.default)(!(0, _tmatch2.default)(this.actual, pattern), message || 'Expected %s to not match %s', this.actual, pattern);

      return this;
    }
  }, {
    key: 'toBeLessThan',
    value: function toBeLessThan(value, message) {
      (0, _assert2.default)(typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeLessThan() must be a number');

      (0, _assert2.default)(typeof value === 'number', 'The "value" argument in toBeLessThan(value) must be a number');

      (0, _assert2.default)(this.actual < value, message || 'Expected %s to be less than %s', this.actual, value);

      return this;
    }
  }, {
    key: 'toBeLessThanOrEqualTo',
    value: function toBeLessThanOrEqualTo(value, message) {
      (0, _assert2.default)(typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeLessThanOrEqualTo() must be a number');

      (0, _assert2.default)(typeof value === 'number', 'The "value" argument in toBeLessThanOrEqualTo(value) must be a number');

      (0, _assert2.default)(this.actual <= value, message || 'Expected %s to be less than or equal to %s', this.actual, value);

      return this;
    }
  }, {
    key: 'toBeGreaterThan',
    value: function toBeGreaterThan(value, message) {
      (0, _assert2.default)(typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeGreaterThan() must be a number');

      (0, _assert2.default)(typeof value === 'number', 'The "value" argument in toBeGreaterThan(value) must be a number');

      (0, _assert2.default)(this.actual > value, message || 'Expected %s to be greater than %s', this.actual, value);

      return this;
    }
  }, {
    key: 'toBeGreaterThanOrEqualTo',
    value: function toBeGreaterThanOrEqualTo(value, message) {
      (0, _assert2.default)(typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeGreaterThanOrEqualTo() must be a number');

      (0, _assert2.default)(typeof value === 'number', 'The "value" argument in toBeGreaterThanOrEqualTo(value) must be a number');

      (0, _assert2.default)(this.actual >= value, message || 'Expected %s to be greater than or equal to %s', this.actual, value);

      return this;
    }
  }, {
    key: 'toInclude',
    value: function toInclude(value, compareValues, message) {
      if (typeof compareValues === 'string') {
        message = compareValues;
        compareValues = null;
      }

      if (compareValues == null) compareValues = _TestUtils.isEqual;

      var contains = false;

      if ((0, _TestUtils.isArray)(this.actual)) {
        contains = (0, _TestUtils.arrayContains)(this.actual, value, compareValues);
      } else if ((0, _TestUtils.isObject)(this.actual)) {
        contains = (0, _TestUtils.objectContains)(this.actual, value, compareValues);
      } else if (typeof this.actual === 'string') {
        contains = (0, _TestUtils.stringContains)(this.actual, value);
      } else {
        (0, _assert2.default)(false, 'The "actual" argument in expect(actual).toInclude() must be an array, object, or a string');
      }

      (0, _assert2.default)(contains, message || 'Expected %s to include %s', this.actual, value);

      return this;
    }
  }, {
    key: 'toExclude',
    value: function toExclude(value, compareValues, message) {
      if (typeof compareValues === 'string') {
        message = compareValues;
        compareValues = null;
      }

      if (compareValues == null) compareValues = _TestUtils.isEqual;

      var contains = false;

      if ((0, _TestUtils.isArray)(this.actual)) {
        contains = (0, _TestUtils.arrayContains)(this.actual, value, compareValues);
      } else if ((0, _TestUtils.isObject)(this.actual)) {
        contains = (0, _TestUtils.objectContains)(this.actual, value, compareValues);
      } else if (typeof this.actual === 'string') {
        contains = (0, _TestUtils.stringContains)(this.actual, value);
      } else {
        (0, _assert2.default)(false, 'The "actual" argument in expect(actual).toExclude() must be an array, object, or a string');
      }

      (0, _assert2.default)(!contains, message || 'Expected %s to exclude %s', this.actual, value);

      return this;
    }
  }, {
    key: 'toIncludeKeys',
    value: function toIncludeKeys(keys, comparator, message) {
      var _this = this;

      if (typeof comparator === 'string') {
        message = comparator;
        comparator = null;
      }

      if (comparator == null) comparator = _has2.default;

      (0, _assert2.default)(_typeof(this.actual) === 'object', 'The "actual" argument in expect(actual).toIncludeKeys() must be an object, not %s', this.actual);

      (0, _assert2.default)((0, _TestUtils.isArray)(keys), 'The "keys" argument in expect(actual).toIncludeKeys(keys) must be an array, not %s', keys);

      var contains = keys.every(function (key) {
        return comparator(_this.actual, key);
      });

      (0, _assert2.default)(contains, message || 'Expected %s to include key(s) %s', this.actual, keys.join(', '));

      return this;
    }
  }, {
    key: 'toIncludeKey',
    value: function toIncludeKey(key) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return this.toIncludeKeys.apply(this, [[key]].concat(args));
    }
  }, {
    key: 'toExcludeKeys',
    value: function toExcludeKeys(keys, comparator, message) {
      var _this2 = this;

      if (typeof comparator === 'string') {
        message = comparator;
        comparator = null;
      }

      if (comparator == null) comparator = _has2.default;

      (0, _assert2.default)(_typeof(this.actual) === 'object', 'The "actual" argument in expect(actual).toExcludeKeys() must be an object, not %s', this.actual);

      (0, _assert2.default)((0, _TestUtils.isArray)(keys), 'The "keys" argument in expect(actual).toIncludeKeys(keys) must be an array, not %s', keys);

      var contains = keys.every(function (key) {
        return comparator(_this2.actual, key);
      });

      (0, _assert2.default)(!contains, message || 'Expected %s to exclude key(s) %s', this.actual, keys.join(', '));

      return this;
    }
  }, {
    key: 'toExcludeKey',
    value: function toExcludeKey(key) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return this.toExcludeKeys.apply(this, [[key]].concat(args));
    }
  }, {
    key: 'toHaveBeenCalled',
    value: function toHaveBeenCalled(message) {
      var spy = this.actual;

      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The "actual" argument in expect(actual).toHaveBeenCalled() must be a spy');

      (0, _assert2.default)(spy.calls.length > 0, message || 'spy was not called');

      return this;
    }
  }, {
    key: 'toHaveBeenCalledWith',
    value: function toHaveBeenCalledWith() {
      for (var _len3 = arguments.length, expectedArgs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        expectedArgs[_key3] = arguments[_key3];
      }

      var spy = this.actual;

      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The "actual" argument in expect(actual).toHaveBeenCalledWith() must be a spy');

      (0, _assert2.default)(spy.calls.some(function (call) {
        return (0, _TestUtils.isEqual)(call.arguments, expectedArgs);
      }), 'spy was never called with %s', expectedArgs);

      return this;
    }
  }, {
    key: 'toNotHaveBeenCalled',
    value: function toNotHaveBeenCalled(message) {
      var spy = this.actual;

      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The "actual" argument in expect(actual).toNotHaveBeenCalled() must be a spy');

      (0, _assert2.default)(spy.calls.length === 0, message || 'spy was not supposed to be called');

      return this;
    }
  }]);

  return Expectation;
}();

var deprecate = function deprecate(fn, message) {
  var alreadyWarned = false;

  return function () {
    if (!alreadyWarned) {
      alreadyWarned = true;
      console.warn(message);
    }

    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return fn.apply(this, args);
  };
};

Expectation.prototype.withContext = deprecate(function (context) {
  (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The "actual" argument in expect(actual).withContext() must be a function');

  this.context = context;

  return this;
}, '\nwithContext is deprecated; use a closure instead.\n\n  expect(fn).withContext(context).toThrow()\n\nbecomes\n\n  expect(() => fn.call(context)).toThrow()\n');

Expectation.prototype.withArgs = deprecate(function () {
  var _args;

  (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The "actual" argument in expect(actual).withArgs() must be a function');

  if (arguments.length) this.args = (_args = this.args).concat.apply(_args, arguments);

  return this;
}, '\nwithArgs is deprecated; use a closure instead.\n\n  expect(fn).withArgs(a, b, c).toThrow()\n\nbecomes\n\n  expect(() => fn(a, b, c)).toThrow()\n');

var aliases = {
  toBeAn: 'toBeA',
  toNotBeAn: 'toNotBeA',
  toBeTruthy: 'toExist',
  toBeFalsy: 'toNotExist',
  toBeFewerThan: 'toBeLessThan',
  toBeMoreThan: 'toBeGreaterThan',
  toContain: 'toInclude',
  toNotContain: 'toExclude',
  toNotInclude: 'toExclude',
  toContainKeys: 'toIncludeKeys',
  toNotContainKeys: 'toExcludeKeys',
  toNotIncludeKeys: 'toExcludeKeys',
  toContainKey: 'toIncludeKey',
  toNotContainKey: 'toExcludeKey',
  toNotIncludeKey: 'toExcludeKey'
};

for (var alias in aliases) {
  if (aliases.hasOwnProperty(alias)) Expectation.prototype[alias] = Expectation.prototype[aliases[alias]];
}exports.default = Expectation;

},{"./SpyUtils":11,"./TestUtils":12,"./assert":13,"has":21,"tmatch":37}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spyOn = exports.createSpy = exports.restoreSpies = exports.isSpy = undefined;

var _defineProperties = require('define-properties');

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _TestUtils = require('./TestUtils');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }return arr2;
  } else {
    return Array.from(arr);
  }
} /*eslint-disable prefer-rest-params, no-underscore-dangle*/

var noop = function noop() {};

var supportsConfigurableFnLength = _defineProperties.supportsDescriptors && Object.getOwnPropertyDescriptor(function () {}, 'length').configurable;

var isSpy = exports.isSpy = function isSpy(object) {
  return object && object.__isSpy === true;
};

var spies = [];

var restoreSpies = exports.restoreSpies = function restoreSpies() {
  for (var i = spies.length - 1; i >= 0; i--) {
    spies[i].restore();
  }spies = [];
};

var createSpy = exports.createSpy = function createSpy(fn) {
  var restore = arguments.length <= 1 || arguments[1] === undefined ? noop : arguments[1];

  if (fn == null) fn = noop;

  (0, _assert2.default)((0, _TestUtils.isFunction)(fn), 'createSpy needs a function');

  var targetFn = void 0,
      thrownValue = void 0,
      returnValue = void 0,
      spy = void 0;

  function spyLogic() {
    spy.calls.push({
      context: this,
      arguments: Array.prototype.slice.call(arguments, 0)
    });

    if (targetFn) return targetFn.apply(this, arguments);

    if (thrownValue) throw thrownValue;

    return returnValue;
  }

  if (supportsConfigurableFnLength) {
    spy = Object.defineProperty(spyLogic, 'length', { value: fn.length, writable: false, enumerable: false, configurable: true });
  } else {
    spy = new Function('spy', 'return function(' + // eslint-disable-line no-new-func
    [].concat(_toConsumableArray(Array(fn.length))).map(function (_, i) {
      return '_' + i;
    }).join(',') + ') {\n      return spy.apply(this, arguments)\n    }')(spyLogic);
  }

  spy.calls = [];

  spy.andCall = function (otherFn) {
    targetFn = otherFn;
    return spy;
  };

  spy.andCallThrough = function () {
    return spy.andCall(fn);
  };

  spy.andThrow = function (value) {
    thrownValue = value;
    return spy;
  };

  spy.andReturn = function (value) {
    returnValue = value;
    return spy;
  };

  spy.getLastCall = function () {
    return spy.calls[spy.calls.length - 1];
  };

  spy.reset = function () {
    spy.calls = [];
  };

  spy.restore = spy.destroy = restore;

  spy.__isSpy = true;

  spies.push(spy);

  return spy;
};

var spyOn = exports.spyOn = function spyOn(object, methodName) {
  var original = object[methodName];

  if (!isSpy(original)) {
    (0, _assert2.default)((0, _TestUtils.isFunction)(original), 'Cannot spyOn the %s property; it is not a function', methodName);

    object[methodName] = createSpy(original, function () {
      object[methodName] = original;
    });
  }

  return object[methodName];
};

},{"./TestUtils":12,"./assert":13,"define-properties":7}],12:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stringContains = exports.objectContains = exports.arrayContains = exports.functionThrows = exports.isA = exports.isObject = exports.isArray = exports.isFunction = exports.isEqual = exports.whyNotEqual = undefined;

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _isRegex = require('is-regex');

var _isRegex2 = _interopRequireDefault(_isRegex);

var _why = require('is-equal/why');

var _why2 = _interopRequireDefault(_why);

var _objectKeys = require('object-keys');

var _objectKeys2 = _interopRequireDefault(_objectKeys);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Returns the reason why the given arguments are not *conceptually*
 * equal, if any; the empty string otherwise.
 */
var whyNotEqual = exports.whyNotEqual = function whyNotEqual(a, b) {
  return a == b ? '' : (0, _why2.default)(a, b);
};

/**
 * Returns true if the given arguments are *conceptually* equal.
 */
var isEqual = exports.isEqual = function isEqual(a, b) {
  return whyNotEqual(a, b) === '';
};

/**
 * Returns true if the given object is a function.
 */
var isFunction = exports.isFunction = function isFunction(object) {
  return typeof object === 'function';
};

/**
 * Returns true if the given object is an array.
 */
var isArray = exports.isArray = function isArray(object) {
  return Array.isArray(object);
};

/**
 * Returns true if the given object is an object.
 */
var isObject = exports.isObject = function isObject(object) {
  return object && !isArray(object) && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';
};

/**
 * Returns true if the given object is an instanceof value
 * or its typeof is the given value.
 */
var isA = exports.isA = function isA(object, value) {
  if (isFunction(value)) return object instanceof value;

  if (value === 'array') return Array.isArray(object);

  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === value;
};

/**
 * Returns true if the given function throws the given value
 * when invoked. The value may be:
 *
 * - undefined, to merely assert there was a throw
 * - a constructor function, for comparing using instanceof
 * - a regular expression, to compare with the error message
 * - a string, to find in the error message
 */
var functionThrows = exports.functionThrows = function functionThrows(fn, context, args, value) {
  try {
    fn.apply(context, args);
  } catch (error) {
    if (value == null) return true;

    if (isFunction(value) && error instanceof value) return true;

    var message = error.message || error;

    if (typeof message === 'string') {
      if ((0, _isRegex2.default)(value) && value.test(error.message)) return true;

      if (typeof value === 'string' && message.indexOf(value) !== -1) return true;
    }
  }

  return false;
};

/**
 * Returns true if the given array contains the value, false
 * otherwise. The compareValues function must return false to
 * indicate a non-match.
 */
var arrayContains = exports.arrayContains = function arrayContains(array, value, compareValues) {
  return array.some(function (item) {
    return compareValues(item, value) !== false;
  });
};

var ownEnumerableKeys = function ownEnumerableKeys(object) {
  if ((typeof Reflect === 'undefined' ? 'undefined' : _typeof(Reflect)) === 'object' && typeof Reflect.ownKeys === 'function') {
    return Reflect.ownKeys(object).filter(function (key) {
      return Object.getOwnPropertyDescriptor(object, key).enumerable;
    });
  }

  if (typeof Object.getOwnPropertySymbols === 'function') {
    return Object.getOwnPropertySymbols(object).filter(function (key) {
      return Object.getOwnPropertyDescriptor(object, key).enumerable;
    }).concat((0, _objectKeys2.default)(object));
  }

  return (0, _objectKeys2.default)(object);
};

/**
 * Returns true if the given object contains the value, false
 * otherwise. The compareValues function must return false to
 * indicate a non-match.
 */
var objectContains = exports.objectContains = function objectContains(object, value, compareValues) {
  return ownEnumerableKeys(value).every(function (k) {
    if (isObject(object[k]) && isObject(value[k])) return objectContains(object[k], value[k], compareValues);

    return compareValues(object[k], value[k]);
  });
};

/**
 * Returns true if the given string contains the value, false otherwise.
 */
var stringContains = exports.stringContains = function stringContains(string, value) {
  return string.indexOf(value) !== -1;
};

},{"is-equal/why":29,"is-regex":32,"object-keys":16}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _objectInspect = require('object-inspect');

var _objectInspect2 = _interopRequireDefault(_objectInspect);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var formatString = function formatString(string, args) {
  var index = 0;
  return string.replace(/%s/g, function () {
    return (0, _objectInspect2.default)(args[index++]);
  });
};

var assert = function assert(condition, createMessage) {
  for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    extraArgs[_key - 2] = arguments[_key];
  }

  if (condition) return;

  var message = typeof createMessage === 'string' ? formatString(createMessage, extraArgs) : createMessage(extraArgs);

  throw new Error(message);
};

exports.default = assert;

},{"object-inspect":35}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Expectation = require('./Expectation');

var _Expectation2 = _interopRequireDefault(_Expectation);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var Extensions = [];

function extend(extension) {
  if (Extensions.indexOf(extension) === -1) {
    Extensions.push(extension);

    for (var p in extension) {
      if (extension.hasOwnProperty(p)) _Expectation2.default.prototype[p] = extension[p];
    }
  }
}

exports.default = extend;

},{"./Expectation":10}],15:[function(require,module,exports){
'use strict';

var _Expectation = require('./Expectation');

var _Expectation2 = _interopRequireDefault(_Expectation);

var _SpyUtils = require('./SpyUtils');

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _extend = require('./extend');

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function expect(actual) {
  return new _Expectation2.default(actual);
}

expect.createSpy = _SpyUtils.createSpy;
expect.spyOn = _SpyUtils.spyOn;
expect.isSpy = _SpyUtils.isSpy;
expect.restoreSpies = _SpyUtils.restoreSpies;
expect.assert = _assert2.default;
expect.extend = _extend2.default;

module.exports = expect;

},{"./Expectation":10,"./SpyUtils":11,"./assert":13,"./extend":14}],16:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"./isArguments":17,"dup":8}],17:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],18:[function(require,module,exports){
'use strict';

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach(obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};

},{}],19:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function binder() {
        if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(that, args.concat(slice.call(arguments)));
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],20:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":19}],21:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":20}],22:[function(require,module,exports){
"use strict";

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

},{}],23:[function(require,module,exports){
'use strict';

var isCallable = require('is-callable');
var fnToStr = Function.prototype.toString;
var isNonArrowFnRegex = /^\s*function/;
var isArrowFnWithParensRegex = /^\([^\)]*\) *=>/;
var isArrowFnWithoutParensRegex = /^[^=]*=>/;

module.exports = function isArrowFunction(fn) {
	if (!isCallable(fn)) {
		return false;
	}
	var fnStr = fnToStr.call(fn);
	return fnStr.length > 0 && !isNonArrowFnRegex.test(fnStr) && (isArrowFnWithParensRegex.test(fnStr) || isArrowFnWithoutParensRegex.test(fnStr));
};

},{"is-callable":25}],24:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var boolToStr = Boolean.prototype.toString;

var tryBooleanObject = function tryBooleanObject(value) {
	try {
		boolToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var boolClass = '[object Boolean]';
var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';

module.exports = function isBoolean(value) {
	if (typeof value === 'boolean') {
		return true;
	}
	if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {
		return false;
	}
	return hasToStringTag ? tryBooleanObject(value) : toStr.call(value) === boolClass;
};

},{}],25:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class /;
var isES6ClassFn = function isES6ClassFn(value) {
	try {
		var fnStr = fnToStr.call(value);
		var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
		var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
		var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
		return constructorRegex.test(spaceStripped);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionObject(value) {
	try {
		if (isES6ClassFn(value)) {
			return false;
		}
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';

module.exports = function isCallable(value) {
	if (!value) {
		return false;
	}
	if (typeof value !== 'function' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {
		return false;
	}
	if (hasToStringTag) {
		return tryFunctionObject(value);
	}
	if (isES6ClassFn(value)) {
		return false;
	}
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};

},{}],26:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';

module.exports = function isDateObject(value) {
	if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || value === null) {
		return false;
	}
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

},{}],27:[function(require,module,exports){
'use strict';

module.exports = function () {
	var mapForEach = function () {
		if (typeof Map !== 'function') {
			return null;
		}
		try {
			Map.prototype.forEach.call({}, function () {});
		} catch (e) {
			return Map.prototype.forEach;
		}
		return null;
	}();

	var setForEach = function () {
		if (typeof Set !== 'function') {
			return null;
		}
		try {
			Set.prototype.forEach.call({}, function () {});
		} catch (e) {
			return Set.prototype.forEach;
		}
		return null;
	}();

	return { Map: mapForEach, Set: setForEach };
};

},{}],28:[function(require,module,exports){
'use strict';

var isSymbol = require('is-symbol');

module.exports = function getSymbolIterator() {
	var symbolIterator = typeof Symbol === 'function' && isSymbol(Symbol.iterator) ? Symbol.iterator : null;

	if (typeof Object.getOwnPropertyNames === 'function' && typeof Map === 'function' && typeof Map.prototype.entries === 'function') {
		Object.getOwnPropertyNames(Map.prototype).forEach(function (name) {
			if (name !== 'entries' && name !== 'size' && Map.prototype[name] === Map.prototype.entries) {
				symbolIterator = name;
			}
		});
	}

	return symbolIterator;
};

},{"is-symbol":34}],29:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var ObjectPrototype = Object.prototype;
var toStr = ObjectPrototype.toString;
var booleanValue = Boolean.prototype.valueOf;
var has = require('has');
var isArrowFunction = require('is-arrow-function');
var isBoolean = require('is-boolean-object');
var isDate = require('is-date-object');
var isGenerator = require('is-generator-function');
var isNumber = require('is-number-object');
var isRegex = require('is-regex');
var isString = require('is-string');
var isSymbol = require('is-symbol');
var isCallable = require('is-callable');

var isProto = Object.prototype.isPrototypeOf;

var namedFoo = function foo() {};
var functionsHaveNames = namedFoo.name === 'foo';

var symbolValue = typeof Symbol === 'function' ? Symbol.prototype.valueOf : null;
var symbolIterator = require('./getSymbolIterator')();

var collectionsForEach = require('./getCollectionsForEach')();

var getPrototypeOf = Object.getPrototypeOf;
if (!getPrototypeOf) {
	/* eslint-disable no-proto */
	if (_typeof('test'.__proto__) === 'object') {
		getPrototypeOf = function getPrototypeOf(obj) {
			return obj.__proto__;
		};
	} else {
		getPrototypeOf = function getPrototypeOf(obj) {
			var constructor = obj.constructor,
			    oldConstructor;
			if (has(obj, 'constructor')) {
				oldConstructor = constructor;
				if (!delete obj.constructor) {
					// reset constructor
					return null; // can't delete obj.constructor, return null
				}
				constructor = obj.constructor; // get real constructor
				obj.constructor = oldConstructor; // restore constructor
			}
			return constructor ? constructor.prototype : ObjectPrototype; // needed for IE
		};
	}
	/* eslint-enable no-proto */
}

var isArray = Array.isArray || function (value) {
	return toStr.call(value) === '[object Array]';
};

var normalizeFnWhitespace = function normalizeWhitespace(fnStr) {
	// this is needed in IE 9, at least, which has inconsistencies here.
	return fnStr.replace(/^function ?\(/, 'function (').replace('){', ') {');
};

var tryMapSetEntries = function tryCollectionEntries(collection) {
	var foundEntries = [];
	try {
		collectionsForEach.Map.call(collection, function (key, value) {
			foundEntries.push([key, value]);
		});
	} catch (notMap) {
		try {
			collectionsForEach.Set.call(collection, function (value) {
				foundEntries.push([value]);
			});
		} catch (notSet) {
			return false;
		}
	}
	return foundEntries;
};

module.exports = function whyNotEqual(value, other) {
	if (value === other) {
		return '';
	}
	if (value == null || other == null) {
		return value === other ? '' : String(value) + ' !== ' + String(other);
	}

	var valToStr = toStr.call(value);
	var otherToStr = toStr.call(other);
	if (valToStr !== otherToStr) {
		return 'toStringTag is not the same: ' + valToStr + ' !== ' + otherToStr;
	}

	var valIsBool = isBoolean(value);
	var otherIsBool = isBoolean(other);
	if (valIsBool || otherIsBool) {
		if (!valIsBool) {
			return 'first argument is not a boolean; second argument is';
		}
		if (!otherIsBool) {
			return 'second argument is not a boolean; first argument is';
		}
		var valBoolVal = booleanValue.call(value);
		var otherBoolVal = booleanValue.call(other);
		if (valBoolVal === otherBoolVal) {
			return '';
		}
		return 'primitive value of boolean arguments do not match: ' + valBoolVal + ' !== ' + otherBoolVal;
	}

	var valIsNumber = isNumber(value);
	var otherIsNumber = isNumber(value);
	if (valIsNumber || otherIsNumber) {
		if (!valIsNumber) {
			return 'first argument is not a number; second argument is';
		}
		if (!otherIsNumber) {
			return 'second argument is not a number; first argument is';
		}
		var valNum = Number(value);
		var otherNum = Number(other);
		if (valNum === otherNum) {
			return '';
		}
		var valIsNaN = isNaN(value);
		var otherIsNaN = isNaN(other);
		if (valIsNaN && !otherIsNaN) {
			return 'first argument is NaN; second is not';
		} else if (!valIsNaN && otherIsNaN) {
			return 'second argument is NaN; first is not';
		} else if (valIsNaN && otherIsNaN) {
			return '';
		}
		return 'numbers are different: ' + value + ' !== ' + other;
	}

	var valIsString = isString(value);
	var otherIsString = isString(other);
	if (valIsString || otherIsString) {
		if (!valIsString) {
			return 'second argument is string; first is not';
		}
		if (!otherIsString) {
			return 'first argument is string; second is not';
		}
		var stringVal = String(value);
		var otherVal = String(other);
		if (stringVal === otherVal) {
			return '';
		}
		return 'string values are different: "' + stringVal + '" !== "' + otherVal + '"';
	}

	var valIsDate = isDate(value);
	var otherIsDate = isDate(other);
	if (valIsDate || otherIsDate) {
		if (!valIsDate) {
			return 'second argument is Date, first is not';
		}
		if (!otherIsDate) {
			return 'first argument is Date, second is not';
		}
		var valTime = +value;
		var otherTime = +other;
		if (valTime === otherTime) {
			return '';
		}
		return 'Dates have different time values: ' + valTime + ' !== ' + otherTime;
	}

	var valIsRegex = isRegex(value);
	var otherIsRegex = isRegex(other);
	if (valIsRegex || otherIsRegex) {
		if (!valIsRegex) {
			return 'second argument is RegExp, first is not';
		}
		if (!otherIsRegex) {
			return 'first argument is RegExp, second is not';
		}
		var regexStringVal = String(value);
		var regexStringOther = String(other);
		if (regexStringVal === regexStringOther) {
			return '';
		}
		return 'regular expressions differ: ' + regexStringVal + ' !== ' + regexStringOther;
	}

	var valIsArray = isArray(value);
	var otherIsArray = isArray(other);
	if (valIsArray || otherIsArray) {
		if (!valIsArray) {
			return 'second argument is an Array, first is not';
		}
		if (!otherIsArray) {
			return 'first argument is an Array, second is not';
		}
		if (value.length !== other.length) {
			return 'arrays have different length: ' + value.length + ' !== ' + other.length;
		}

		var index = value.length - 1;
		var equal = '';
		var valHasIndex, otherHasIndex;
		while (equal === '' && index >= 0) {
			valHasIndex = has(value, index);
			otherHasIndex = has(other, index);
			if (!valHasIndex && otherHasIndex) {
				return 'second argument has index ' + index + '; first does not';
			}
			if (valHasIndex && !otherHasIndex) {
				return 'first argument has index ' + index + '; second does not';
			}
			equal = whyNotEqual(value[index], other[index]);
			index -= 1;
		}
		return equal;
	}

	var valueIsSym = isSymbol(value);
	var otherIsSym = isSymbol(other);
	if (valueIsSym !== otherIsSym) {
		if (valueIsSym) {
			return 'first argument is Symbol; second is not';
		}
		return 'second argument is Symbol; first is not';
	}
	if (valueIsSym && otherIsSym) {
		return symbolValue.call(value) === symbolValue.call(other) ? '' : 'first Symbol value !== second Symbol value';
	}

	var valueIsGen = isGenerator(value);
	var otherIsGen = isGenerator(other);
	if (valueIsGen !== otherIsGen) {
		if (valueIsGen) {
			return 'first argument is a Generator; second is not';
		}
		return 'second argument is a Generator; first is not';
	}

	var valueIsArrow = isArrowFunction(value);
	var otherIsArrow = isArrowFunction(other);
	if (valueIsArrow !== otherIsArrow) {
		if (valueIsArrow) {
			return 'first argument is an Arrow function; second is not';
		}
		return 'second argument is an Arrow function; first is not';
	}

	if (isCallable(value) || isCallable(other)) {
		if (functionsHaveNames && whyNotEqual(value.name, other.name) !== '') {
			return 'Function names differ: "' + value.name + '" !== "' + other.name + '"';
		}
		if (whyNotEqual(value.length, other.length) !== '') {
			return 'Function lengths differ: ' + value.length + ' !== ' + other.length;
		}

		var valueStr = normalizeFnWhitespace(String(value));
		var otherStr = normalizeFnWhitespace(String(other));
		if (whyNotEqual(valueStr, otherStr) === '') {
			return '';
		}

		if (!valueIsGen && !valueIsArrow) {
			return whyNotEqual(valueStr.replace(/\)\s*\{/, '){'), otherStr.replace(/\)\s*\{/, '){')) === '' ? '' : 'Function string representations differ';
		}
		return whyNotEqual(valueStr, otherStr) === '' ? '' : 'Function string representations differ';
	}

	if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' || (typeof other === 'undefined' ? 'undefined' : _typeof(other)) === 'object') {
		if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== (typeof other === 'undefined' ? 'undefined' : _typeof(other))) {
			return 'arguments have a different typeof: ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ' !== ' + (typeof other === 'undefined' ? 'undefined' : _typeof(other));
		}
		if (isProto.call(value, other)) {
			return 'first argument is the [[Prototype]] of the second';
		}
		if (isProto.call(other, value)) {
			return 'second argument is the [[Prototype]] of the first';
		}
		if (getPrototypeOf(value) !== getPrototypeOf(other)) {
			return 'arguments have a different [[Prototype]]';
		}

		if (symbolIterator) {
			var valueIteratorFn = value[symbolIterator];
			var valueIsIterable = isCallable(valueIteratorFn);
			var otherIteratorFn = other[symbolIterator];
			var otherIsIterable = isCallable(otherIteratorFn);
			if (valueIsIterable !== otherIsIterable) {
				if (valueIsIterable) {
					return 'first argument is iterable; second is not';
				}
				return 'second argument is iterable; first is not';
			}
			if (valueIsIterable && otherIsIterable) {
				var valueIterator = valueIteratorFn.call(value);
				var otherIterator = otherIteratorFn.call(other);
				var valueNext, otherNext, nextWhy;
				do {
					valueNext = valueIterator.next();
					otherNext = otherIterator.next();
					if (!valueNext.done && !otherNext.done) {
						nextWhy = whyNotEqual(valueNext, otherNext);
						if (nextWhy !== '') {
							return 'iteration results are not equal: ' + nextWhy;
						}
					}
				} while (!valueNext.done && !otherNext.done);
				if (valueNext.done && !otherNext.done) {
					return 'first argument finished iterating before second';
				}
				if (!valueNext.done && otherNext.done) {
					return 'second argument finished iterating before first';
				}
				return '';
			}
		} else if (collectionsForEach.Map || collectionsForEach.Set) {
			var valueEntries = tryMapSetEntries(value);
			var otherEntries = tryMapSetEntries(other);
			var valueEntriesIsArray = isArray(valueEntries);
			var otherEntriesIsArray = isArray(otherEntries);
			if (valueEntriesIsArray && !otherEntriesIsArray) {
				return 'first argument has Collection entries, second does not';
			}
			if (!valueEntriesIsArray && otherEntriesIsArray) {
				return 'second argument has Collection entries, first does not';
			}
			if (valueEntriesIsArray && otherEntriesIsArray) {
				var entriesWhy = whyNotEqual(valueEntries, otherEntries);
				return entriesWhy === '' ? '' : 'Collection entries differ: ' + entriesWhy;
			}
		}

		var key, valueKeyIsRecursive, otherKeyIsRecursive, keyWhy;
		for (key in value) {
			if (has(value, key)) {
				if (!has(other, key)) {
					return 'first argument has key "' + key + '"; second does not';
				}
				valueKeyIsRecursive = !!value[key] && value[key][key] === value;
				otherKeyIsRecursive = !!other[key] && other[key][key] === other;
				if (valueKeyIsRecursive !== otherKeyIsRecursive) {
					if (valueKeyIsRecursive) {
						return 'first argument has a circular reference at key "' + key + '"; second does not';
					}
					return 'second argument has a circular reference at key "' + key + '"; first does not';
				}
				if (!valueKeyIsRecursive && !otherKeyIsRecursive) {
					keyWhy = whyNotEqual(value[key], other[key]);
					if (keyWhy !== '') {
						return 'value at key "' + key + '" differs: ' + keyWhy;
					}
				}
			}
		}
		for (key in other) {
			if (has(other, key) && !has(value, key)) {
				return 'second argument has key "' + key + '"; first does not';
			}
		}
		return '';
	}

	return false;
};

},{"./getCollectionsForEach":27,"./getSymbolIterator":28,"has":21,"is-arrow-function":23,"is-boolean-object":24,"is-callable":25,"is-date-object":26,"is-generator-function":30,"is-number-object":31,"is-regex":32,"is-string":33,"is-symbol":34}],30:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function getGeneratorFunc() {
	// eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {}
};
var generatorFunc = getGeneratorFunc();
var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	return getProto(fn) === GeneratorFunction;
};

},{}],31:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var numToStr = Number.prototype.toString;
var tryNumberObject = function tryNumberObject(value) {
	try {
		numToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var numClass = '[object Number]';
var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';

module.exports = function isNumberObject(value) {
	if (typeof value === 'number') {
		return true;
	}
	if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {
		return false;
	}
	return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
};

},{}],32:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var has = require('has');
var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;

var tryRegexExecCall = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0;

		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex;
	}
};
var toStr = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';

module.exports = function isRegex(value) {
	if (!value || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {
		return false;
	}
	if (!hasToStringTag) {
		return toStr.call(value) === regexClass;
	}

	var descriptor = gOPD(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall(value);
};

},{"has":21}],33:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject(value) {
	try {
		strValue.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var strClass = '[object String]';
var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';

module.exports = function isString(value) {
	if (typeof value === 'string') {
		return true;
	}
	if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {
		return false;
	}
	return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
};

},{}],34:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var toStr = Object.prototype.toString;
var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol()) === 'symbol';

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isSymbolObject(value) {
		if (_typeof(value.valueOf()) !== 'symbol') {
			return false;
		}
		return symStringRegex.test(symToStr.call(value));
	};
	module.exports = function isSymbol(value) {
		if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol') {
			return true;
		}
		if (toStr.call(value) !== '[object Symbol]') {
			return false;
		}
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {
	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return false;
	};
}

},{}],35:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;

var inspectCustom = require('./util.inspect').custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, opts, depth, seen) {
    if (!opts) opts = {};

    if (has(opts, 'quoteStyle') && opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double') {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        return String(obj);
    }
    if (typeof obj === 'bigint') {
        return String(obj) + 'n';
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') depth = 0;
    if (depth >= maxDepth && maxDepth > 0 && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
        return '[Object]';
    }

    if (typeof seen === 'undefined') seen = [];else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function') {
        var name = nameOf(obj);
        return '[Function' + (name ? ': ' + name : '') + ']';
    }
    if (isSymbol(obj)) {
        var symString = Symbol.prototype.toString.call(obj);
        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) s += '...';
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) return '[]';
        return '[ ' + arrObjKeys(obj, inspect).join(', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (parts.length === 0) return '[' + String(obj) + ']';
        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';
    }
    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {
            return obj[inspectSymbol]();
        } else if (typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var parts = [];
        mapForEach.call(obj, function (value, key) {
            parts.push(inspect(key, obj) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), parts);
    }
    if (isSet(obj)) {
        var parts = [];
        setForEach.call(obj, function (value) {
            parts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), parts);
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var xs = arrObjKeys(obj, inspect);
        if (xs.length === 0) return '{}';
        return '{ ' + xs.join(', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray(obj) {
    return toStr(obj) === '[object Array]';
}
function isDate(obj) {
    return toStr(obj) === '[object Date]';
}
function isRegExp(obj) {
    return toStr(obj) === '[object RegExp]';
}
function isError(obj) {
    return toStr(obj) === '[object Error]';
}
function isSymbol(obj) {
    return toStr(obj) === '[object Symbol]';
}
function isString(obj) {
    return toStr(obj) === '[object String]';
}
function isNumber(obj) {
    return toStr(obj) === '[object Number]';
}
function isBigInt(obj) {
    return toStr(obj) === '[object BigInt]';
}
function isBoolean(obj) {
    return toStr(obj) === '[object Boolean]';
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) {
    return key in this;
};
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) return f.name;
    var m = String(f).match(/^function\s*([\w$]+)/);
    if (m) return m[1];
}

function indexOf(xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
}

function isMap(x) {
    if (!mapSize) {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize) {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) !== 'object') return false;
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[n];
    if (x) return '\\' + x;
    return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function collectionOf(type, size, entries) {
    return type + ' (' + size + ') {' + entries.join(', ') + '}';
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    for (var key in obj) {
        if (!has(obj, key)) continue;
        if (isArr && String(Number(key)) === key && key < obj.length) continue;
        if (/[^\w$]/.test(key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    return xs;
}

},{"./util.inspect":4}],36:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],37:[function(require,module,exports){
(function (process,Buffer){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isArguments(obj) {
  return Object.prototype.toString.call(obj) === '[object Arguments]';
}

module.exports = match;

function match(obj, pattern) {
  return match_(obj, pattern, [], []);
}

/* istanbul ignore next */
var log = /\btmatch\b/.test(process.env.NODE_DEBUG || '') ? console.error : function () {};

function match_(obj, pattern, ca, cb) {
  log('TMATCH', typeof obj === 'undefined' ? 'undefined' : _typeof(obj), pattern);
  if (obj == pattern) {
    log('TMATCH same object or simple value, or problem');
    // if one is object, and the other isn't, then this is bogus
    if (obj === null || pattern === null) {
      return true;
    } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && (typeof pattern === 'undefined' ? 'undefined' : _typeof(pattern)) === 'object') {
      return true;
    } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && (typeof pattern === 'undefined' ? 'undefined' : _typeof(pattern)) !== 'object') {
      return false;
    } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && (typeof pattern === 'undefined' ? 'undefined' : _typeof(pattern)) === 'object') {
      return false;
    } else {
      return true;
    }
  } else if (obj === null || pattern === null) {
    log('TMATCH null test, already failed ==');
    return false;
  } else if (typeof obj === 'string' && pattern instanceof RegExp) {
    log('TMATCH string~=regexp test');
    return pattern.test(obj);
  } else if (typeof obj === 'string' && typeof pattern === 'string' && pattern) {
    log('TMATCH string~=string test');
    return obj.indexOf(pattern) !== -1;
  } else if (obj instanceof Date && pattern instanceof Date) {
    log('TMATCH date test');
    return obj.getTime() === pattern.getTime();
  } else if (obj instanceof Date && typeof pattern === 'string') {
    log('TMATCH date~=string test');
    return obj.getTime() === new Date(pattern).getTime();
  } else if (isArguments(obj) || isArguments(pattern)) {
    log('TMATCH arguments test');
    var slice = Array.prototype.slice;
    return match_(slice.call(obj), slice.call(pattern), ca, cb);
  } else if (pattern === Buffer) {
    log('TMATCH Buffer ctor');
    return Buffer.isBuffer(obj);
  } else if (pattern === Function) {
    log('TMATCH Function ctor');
    return typeof obj === 'function';
  } else if (pattern === Number) {
    log('TMATCH Number ctor (finite, not NaN)');
    return typeof obj === 'number' && obj === obj && isFinite(obj);
  } else if (pattern !== pattern) {
    log('TMATCH NaN');
    return obj !== obj;
  } else if (pattern === String) {
    log('TMATCH String ctor');
    return typeof obj === 'string';
  } else if (pattern === Boolean) {
    log('TMATCH Boolean ctor');
    return typeof obj === 'boolean';
  } else if (pattern === Array) {
    log('TMATCH Array ctor', pattern, Array.isArray(obj));
    return Array.isArray(obj);
  } else if (typeof pattern === 'function' && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
    log('TMATCH object~=function');
    return obj instanceof pattern;
  } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || (typeof pattern === 'undefined' ? 'undefined' : _typeof(pattern)) !== 'object') {
    log('TMATCH obj is not object, pattern is not object, false');
    return false;
  } else if (obj instanceof RegExp && pattern instanceof RegExp) {
    log('TMATCH regexp~=regexp test');
    return obj.source === pattern.source && obj.global === pattern.global && obj.multiline === pattern.multiline && obj.lastIndex === pattern.lastIndex && obj.ignoreCase === pattern.ignoreCase;
  } else if (Buffer.isBuffer(obj) && Buffer.isBuffer(pattern)) {
    log('TMATCH buffer test');
    if (obj.equals) {
      return obj.equals(pattern);
    } else {
      if (obj.length !== pattern.length) return false;

      for (var j = 0; j < obj.length; j++) {
        if (obj[j] != pattern[j]) return false;
      }return true;
    }
  } else {
    // both are objects.  interesting case!
    log('TMATCH object~=object test');
    var kobj = Object.keys(obj);
    var kpat = Object.keys(pattern);
    log('  TMATCH patternkeys=%j objkeys=%j', kpat, kobj);

    // don't bother with stack acrobatics if there's nothing there
    if (kobj.length === 0 && kpat.length === 0) return true;

    // if we've seen this exact pattern and object already, then
    // it means that pattern and obj have matching cyclicalness
    // however, non-cyclical patterns can match cyclical objects
    log('  TMATCH check seen objects...');
    var cal = ca.length;
    while (cal--) {
      if (ca[cal] === obj && cb[cal] === pattern) return true;
    }ca.push(obj);cb.push(pattern);
    log('  TMATCH not seen previously');

    var key;
    for (var l = kpat.length - 1; l >= 0; l--) {
      key = kpat[l];
      log('  TMATCH test obj[%j]', key, obj[key], pattern[key]);
      if (!match_(obj[key], pattern[key], ca, cb)) return false;
    }

    ca.pop();
    cb.pop();

    log('  TMATCH object pass');
    return true;
  }

  /* istanbul ignore next */
  throw new Error('impossible to reach this point');
}

}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":36,"buffer":6}],38:[function(require,module,exports){
(function (global,Buffer){
'use strict';

var bindexOf = require('bindexof'),
    Config = require('./lib/config.json'),
    Package = require('./package.json'),
    Transcoder = require('./lib/transcoder.js'),
    Webcrypto = require('node-webcrypto-ossl'),
    transcoder = new Transcoder();

global.Buffer = global.Buffer || Buffer;

module.exports = exports = {

    cipher: function cipher(options) {

        var config = JSON.parse(JSON.stringify(Config)),
            material = {},
            wcrypt = this;

        try {
            wcrypt.crypto = new Webcrypto();
        } catch (err) {
            wcrypt.crypto = window.crypto || window.msCrypto;
        }

        if (typeof options === 'string') {
            options = {
                config: {},
                material: {
                    passphrase: options
                }
            };
        } else if (Array.isArray(options) || typeof options === 'number') {
            throw Error(Config.err.passReq);
        } else if (!options.config) {
            options.config = {};
        } else if (!options.material) {
            options.material = {};
        }

        _overrideConfig(options.config);
        _setMaterial(options.material);
        exports.setHeader(config);

        exports.debug('Debugging enabled.');

        wcrypt.createHeader = function () {
            return Buffer.concat([exports.getSignature(config), Buffer.from(config.derive.iterations.toString(), 'utf8'), Buffer.from(config.crypto.tagLength.toString(), 'utf8'), Buffer.from(config.derive.length.toString(), 'utf8'), Buffer.from(config.derive.hash.toString(), 'utf8'), transcoder.ab2buf(material.iv), transcoder.ab2buf(material.salt), wcrypt.getDelimiter()]);
        };
        wcrypt.decrypt = function (data) {
            return wcrypt.rawDecrypt(data, { assumeHeader: true });
        };
        wcrypt.delimiter = config.delimiter;
        wcrypt.encrypt = function (data) {
            return wcrypt.rawEncrypt(data, { includeHeader: true });
        };
        wcrypt.encryptDelimited = function (data) {
            return wcrypt.rawEncrypt(data, { appendDelimiter: true });
        };
        wcrypt.getDelimiter = function () {
            exports.debug('getDelimiter', config.delimiter);
            return Buffer.from(config.delimiter);
        };
        wcrypt.name = Package.name;
        wcrypt.rawDecrypt = _decrypt;
        wcrypt.rawEncrypt = _encrypt;
        wcrypt.subtle = wcrypt.crypto.subtle || wcrypt.crypto.webkitSubtle;
        wcrypt.uriSafeBase64 = function (data) {
            return transcoder.b642uri(transcoder.buf2b64(data));
        };

        function _decrypt(chunk, options) {
            options = options || {};
            var data;
            if (options.assumeHeader) {
                var parsed = exports.parseHeader(chunk);
                data = parsed.payload;
                _overrideConfig(parsed.config);
                _setMaterial(parsed.material);
                exports.debug('_decrypt salt', Buffer.from(material.salt).toString('hex'));
            } else {
                data = chunk;
            }
            exports.debug('_decrypt', JSON.stringify(options));
            return _getKey().then(function (key) {
                material.key = key;
                return _wDecrypt(data);
            }).catch(function (err) {
                throw err;
            }).then(function (data) {
                return data;
            }).catch(function (err) {
                throw err;
            });
        }

        function _deriveKey() {
            exports.debug('_deriveKey salt', Buffer.from(material.salt).toString('hex'));
            return wcrypt.subtle.deriveKey({
                name: config.derive.algorithm,
                salt: material.salt,
                iterations: config.derive.iterations,
                hash: config.derive.hash
            }, material.baseKey, {
                name: config.crypto.algorithm,
                length: config.derive.length
            }, true, config.crypto.usages);
        }

        function _encrypt(data, options) {
            options = options || {};
            exports.debug('_encrypt', JSON.stringify(options));
            if (typeof data === 'string') {
                data = Buffer.from(data, 'utf8');
            }
            return _getKey().then(function (key) {
                material.key = key;
                return _wEncrypt(data);
            }).catch(function (err) {
                throw err;
            }).then(function (result) {
                if (config.paranoid) {
                    if (bindexOf(result, wcrypt.getDelimiter())) _encrypt(data, options);
                }
                return _encryptedBlock(result, options);
            }).catch(function (err) {
                throw err;
            });
        }

        function _encryptedBlock(data, options) {
            options = options || {};
            exports.debug('_encryptedBlock', JSON.stringify(options));
            if (options.appendDelimiter && !options.includeHeader) {
                return Buffer.concat([data, wcrypt.getDelimiter()]);
            } else if (!options.appendDelimiter && options.includeHeader) {
                return Buffer.concat([wcrypt.createHeader(), data]);
            } else if (options.includeHeader && options.appendDelimiter) {
                return Buffer.concat([wcrypt.createHeader(), data, wcrypt.getDelimiter()]);
            } else {
                return data;
            }
        }

        function _getKey() {
            if (material.key) {
                return new Promise(function (resolve, reject) {
                    resolve(material.key);
                });
            } else {
                return _importKey().catch(function (err) {
                    throw err;
                }).then(function (key) {
                    material.baseKey = key;
                    return _deriveKey();
                }).catch(function (err) {
                    throw err;
                });
            }
        }

        function _getRandomBytes(numBytes) {
            var buf = new Uint8Array(numBytes);
            return wcrypt.crypto.getRandomValues(buf);
        }

        function _importKey() {
            if (typeof material.passphrase !== 'string') {
                return Promise.reject(config.err.passString);
            } else {
                return wcrypt.subtle.importKey('raw', transcoder.str2ab(material.passphrase), { 'name': config.derive.algorithm }, false, ['deriveKey']);
            }
        }

        function _overrideConfig(overrides) {
            overrides = overrides || {};

            if (!overrides.crypto) overrides.crypto = {};
            if (!overrides.derive) overrides.derive = {};

            exports.debug('_overrideConfig overrides', JSON.stringify(overrides));
            config.crypto.usages = overrides.crypto.usages || config.crypto.usages;
            config.crypto.tagLength = overrides.crypto.tagLength || config.crypto.tagLength;
            config.derive.algorithm = overrides.derive.algorithm || config.derive.algorithm;
            config.derive.hash = overrides.derive.hash || config.derive.hash;
            config.derive.iterations = overrides.derive.iterations || config.derive.iterations;
            config.derive.length = overrides.derive.length || config.derive.length;
            config.paranoid = overrides.paranoid || false;
            exports.debug('_overrideConfig result', JSON.stringify(config));
        };

        function _setMaterial(params) {
            params = params || {};
            exports.debug('_setMaterial params', JSON.stringify(params));
            material.iv = params.iv || material.iv || _getRandomBytes(12);
            material.passphrase = params.passphrase || material.passphrase;
            material.salt = params.salt || material.salt || _getRandomBytes(16);
            exports.debug('_setMaterial result', JSON.stringify(material));
        }

        function _uriSafeBase64(data) {
            return transcoder.b642uri(transcoder.buf2b64(data));
        }

        function _wDecrypt(data) {
            return wcrypt.subtle.decrypt({
                name: config.crypto.algorithm,
                iv: material.iv,
                tagLength: config.crypto.tagLength
            }, material.key, transcoder.buf2ab(data)).then(function (result) {
                return transcoder.ab2buf(result);
            }).catch(function (err) {
                throw err;
            });
        }

        function _wEncrypt(data) {
            return wcrypt.subtle.encrypt({
                name: config.crypto.algorithm,
                iv: material.iv,
                tagLength: config.crypto.tagLength
            }, material.key, transcoder.buf2ab(data)).then(function (result) {
                return transcoder.ab2buf(result);
            }).catch(function (err) {
                throw err;
            });
        }
    },

    debug: function debug() {
        var msg = Array.prototype.slice.call(arguments);
        msg.unshift('[debug] ');
        msg = msg.join(' ');
        if (exports.DEBUG) console.error(msg);
    },

    delimiter: Config.delimiter,

    getSignature: function getSignature(config) {
        var v = exports.version.split('.');
        for (var i = 0; i < v.length; i++) {
            if (v[i].length < 2) v[i] = '0' + v[i];
        }
        v = v.join('.');
        var signature;
        if (config) signature = config.signaturePrefix;else signature = Config.signaturePrefix;
        signature = signature + v;
        return Buffer.from(signature);
    },

    parseHeader: function parseHeader(data) {
        var config = JSON.parse(JSON.stringify(Config)),
            material = {};

        exports.setHeader(config);

        var signature = data.slice(0, exports.head.sig.e).toString('utf8'),
            prefix = signature.substring(0, exports.head.pref),
            version = signature.substring(exports.head.pref, exports.head.sig.e);

        if (prefix != config.signaturePrefix) throw new Error(Config.err.sigInvalid + Package.name + Package.version);else if (parseInt(version) > parseInt(Package.version)) console.error(Config.err.encryptOld + Package.name);else if (parseInt(version) < parseInt(Package.version)) console.error(Config.err.encryptNew + Package.name);

        //00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  16  17  18
        // W   C   R   Y   P   T   m   v   .   m   v   .   p   v   2   0   0   0
        //19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36
        // 1   2   8   1   2   8   S   H   A   -   5   1   2   i   n   i   t   v
        //37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54
        // e   c   t   o   r   -   s   a   l   t   -   -   -   -   -   -   -   -
        //55  56  57  58  59  60  61  62  63  64  65  66
        // -   -   -   -   <   W   c   R   y   P   +   >
        config.derive.iterations = parseInt(data.slice(exports.head.iter.b, exports.head.iter.e).toString('utf8'));
        config.crypto.tagLength = parseInt(data.slice(exports.head.tag.b, exports.head.tag.e).toString('utf8'));
        config.derive.length = parseInt(data.slice(exports.head.length.b, exports.head.length.e).toString('utf8'));
        config.derive.hash = data.slice(exports.head.hash.b, exports.head.hash.e).toString('utf8');
        material.iv = transcoder.buf2ab(data.slice(exports.head.iv.b, exports.head.iv.e));
        material.salt = transcoder.buf2ab(data.slice(exports.head.salt.b, exports.head.salt.e));

        return {
            config: config,
            material: material,
            payload: data.slice(exports.head.salt.e + config.delimiter.length)
        };
    },

    setHeader: function setHeader(config) {
        var sigPos = exports.getSignature(config).length,
            iterPos = sigPos + config.derive.iterations.toString().length,
            tagPos = iterPos + config.crypto.tagLength.toString().length,
            _length = tagPos + config.derive.length.toString().length,
            hashPos = _length + config.derive.hash.length,
            ivPos = hashPos + config.crypto.ivLength,
            saltPos = ivPos + config.derive.saltLength;

        exports.head = {
            hash: { b: _length, e: hashPos },
            iter: { b: sigPos, e: iterPos },
            iv: { b: hashPos, e: ivPos },
            length: { b: tagPos, e: _length },
            pref: config.signaturePrefix.length,
            salt: { b: ivPos, e: saltPos },
            sig: { b: 0, e: sigPos },
            tag: { b: iterPos, e: tagPos }
        };
    },

    version: Package.version

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./lib/config.json":39,"./lib/transcoder.js":40,"./package.json":41,"bindexof":2,"buffer":6,"node-webcrypto-ossl":5}],39:[function(require,module,exports){
module.exports={
    "cmdline": {
       "arg": "read data from command line",
       "debug": "write debug info to stderr",
       "ex1": ["cat msg.txt | $0 -o msg.wcrypt", "encrypt,store in file"],
       "ex2": ["cat msg.wcrypt | $0 -d", "decrypt"],
       "ex3": ["curl http:..:4196 | $0 > aud.wcrypt", "stream to encrypt"],
       "ex4": ["$0 -i msg.txt -o msg.wcrypt", "file to encrypt"],
       "ex5": ["$0 -di msg.wcrypt -o msg.txt", "file to decrypt"],
       "ex6": ["$0 -a \"nonessential appliances\"", "string to encrypt"],
       "infile": "read data from this file",
       "outfile": "write data to this file",
       "passConf": "Confirm passphrase: ",
       "passPrompt": "Passphrase? ",
       "pipeUsage": "Usage: data | $0 [options]",
       "usage": "$0 [options]",
       "version": "display version and exit"
    },
    "crypto": {
        "algorithm": "AES-GCM",
        "ivLength": 12,
        "usages": ["encrypt", "decrypt"],
        "tagLength": 128
    },
    "derive": {
        "algorithm": "PBKDF2",
        "hash": "SHA-512",
        "length": 128,
        "iterations": 2000,
        "saltLength": 16
    },
    "delimiter": "<WcRyP+>",
    "err": {
        "chunkDecrypt": "Could not decrypt chunk- ",
        "chunkEncrypt": "Could not encrypt chunk- ",
        "encryptNew": "Data encrypted with an earlier version of ",
        "encryptOld": "Data encrypted with a later version of ",
        "fileDecrypt": "Could not decrypt file- ",
        "filePerms": "File permissions are insecure.",
        "passBlank": "Passphrase cannot be blank.",
        "passString": "Incoming passphrase must be a string.",
        "passReq": "Please pass in a passphrase string or options object.",
        "sigInvalid": "Invalid file signature "
    },
    "signaturePrefix": "WCRYPT",
    "suffix": "wcrypt"
}

},{}],40:[function(require,module,exports){
(function (Buffer){
'use strict';

module.exports = exports = function exports() {

    var transcoder = this;

    transcoder.ab2b64 = function (arrayBuffer) {
        if (!arrayBuffer) return;
        var typedArray = Buffer.from(new Uint8Array(arrayBuffer));
        return typedArray.toString('base64');
    };

    transcoder.ab2buf = function (ab) {
        var buf = Buffer.alloc(ab.byteLength);
        var view = new Uint8Array(ab);
        for (var i = 0; i < buf.length; ++i) {
            buf[i] = view[i];
        }
        return buf;
    };

    transcoder.ab2hex = function (arrayBuffer) {
        if (!arrayBuffer) return;
        var typedArray = Buffer.from(new Uint8Array(arrayBuffer));
        return typedArray.toString('hex');
    };

    transcoder.ab2str = function (ab) {
        return Buffer.from(transcoder.ab2buf(ab)).toString('utf8');
    };

    transcoder.ab2uri = function (arrayBuffer) {
        if (!arrayBuffer) return;
        return transcoder.b642uri(transcoder.ab2b64(arrayBuffer));
    };

    transcoder.b642buf = function (b64) {
        if (!b64) return;
        return Buffer.from(b64);
    };

    transcoder.b642uint8 = function (b64) {
        if (!b64) return;
        var b64Buffer = Buffer.from(b64, 'base64');
        return transcoder.buf2ab(b64Buffer);
    };

    transcoder.b642uri = function (b64) {
        if (!b64) return;
        return b64.replace(/=/g, '-').replace(/\+/g, '.').replace(/\//g, '_');
    };

    transcoder.buf2ab = function (buf) {
        if (!buf) return;
        var ab = new ArrayBuffer(buf.length);
        var view = new Uint8Array(ab);
        for (var i = 0; i < buf.length; ++i) {
            view[i] = buf[i];
        }
        return ab;
    };

    transcoder.buf2b64 = function (buf) {
        if (!buf) return;
        return buf.toString('base64');
    };

    transcoder.buf2hex = function (buf) {
        if (!buf) return;
        return buf.toString('hex');
    };

    transcoder.buf2str = function (buf) {
        if (!buf) return;
        return buf.toString('utf8');
    };

    transcoder.buf2uri = function (buf) {
        if (!buf) return;
        return transcoder.b642uri(transcoder.buf2b64(buf));
    };

    transcoder.hex2ab = function (hex) {
        if (!hex) return;
        var hexBuffer = Buffer.from(hex, 'hex');
        return transcoder.buf2ab(hexBuffer);
    };

    transcoder.hex2buf = function (hex) {
        if (!hex) return;
        return Buffer.from(hex, 'hex');
    };

    transcoder.str2ab = function (str) {
        if (!str) return;
        str = Buffer.from(str, 'utf8');
        var arrayBuffer = new ArrayBuffer(str.length);
        var arrayBufferView = new Uint8Array(arrayBuffer);
        for (var i = 0, strLen = str.length; i < strLen; i++) {
            arrayBufferView[i] = str[i];
        }
        return arrayBuffer;
    };

    transcoder.str2buf = function (str) {
        if (!str) return;
        var typedArray = transcoder.str2ab(str);
        return Buffer.from(typedArray, 'utf8');
    };

    transcoder.uri2buf = function (uriString) {
        if (!uriString) return;
        var base64 = transcoder.uri2b64(uriString);
        return Buffer.from(base64, 'base64');
    };
};

}).call(this,require("buffer").Buffer)
},{"buffer":6}],41:[function(require,module,exports){
module.exports={
  "_from": "webcrypto-crypt@^0.1.18",
  "_id": "webcrypto-crypt@0.1.18",
  "_inBundle": false,
  "_integrity": "sha512-fvU8flled0WLBh6jC2ruVioQmU1lA4Q2eWRVj668FgxZat1skpKiZr7d1aGj7OIiUbJAe9tqv+TTGcvuNCMgGQ==",
  "_location": "/webcrypto-crypt",
  "_phantomChildren": {
    "decamelize": "1.2.0",
    "error-ex": "1.3.2",
    "get-caller-file": "1.0.2",
    "graceful-fs": "4.1.11",
    "is-utf8": "0.2.1",
    "lcid": "1.0.0",
    "normalize-package-data": "2.4.0",
    "pinkie-promise": "2.0.1",
    "require-directory": "2.1.1",
    "require-main-filename": "1.0.1",
    "set-blocking": "2.0.0",
    "string-width": "1.0.2",
    "strip-ansi": "3.0.1",
    "wrap-ansi": "2.1.0",
    "y18n": "3.2.1"
  },
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "webcrypto-crypt@^0.1.18",
    "name": "webcrypto-crypt",
    "escapedName": "webcrypto-crypt",
    "rawSpec": "^0.1.18",
    "saveSpec": null,
    "fetchSpec": "^0.1.18"
  },
  "_requiredBy": [
    "/ipfsecret"
  ],
  "_resolved": "https://registry.npmjs.org/webcrypto-crypt/-/webcrypto-crypt-0.1.18.tgz",
  "_shasum": "3f80839ef3c771dd9fec55642e574b5da4dd2ca3",
  "_spec": "webcrypto-crypt@^0.1.18",
  "_where": "/home/dps/ipfs/node_modules/ipfsecret",
  "author": {
    "name": "C2FO Innovation Lab"
  },
  "bin": {
    "wcrypt": "./bin/wcrypt.js"
  },
  "bugs": {
    "url": "https://github.com/c2fo-lab/webcrypto-crypt/issues",
    "email": "labs@c2fo.com"
  },
  "bundleDependencies": false,
  "dependencies": {
    "async": "^2.2.0",
    "babel-preset-env": "^1.7.0",
    "babel-register": "^6.26.0",
    "babelify": "^7.3.0",
    "binary-split": "^1.0.3",
    "bindexof": "^1.0.1",
    "blob-to-buffer": "^1.2.8",
    "browserify": "^16.2.2",
    "chop": "0.0.1",
    "expect": "^1.20.2",
    "fstat-mode": "0.0.1",
    "mkdirp": "^0.5.1",
    "node-webcrypto-ossl": "^1.0.37",
    "npm": "^6.1.0",
    "readline-sync": "^1.4.9",
    "through2": "^2.0.3",
    "yargs": "^7.1.0"
  },
  "deprecated": false,
  "description": "Symmetric cryptography with a passphrase for node and the browser ",
  "devDependencies": {
    "mocha": "^5.2.0"
  },
  "engines": {
    "node": "8",
    "npm": "4.5"
  },
  "homepage": "https://c2fo-lab.github.io/webcrypto-crypt",
  "keywords": [
    "webcrypto",
    "aes-gcm",
    "pbkdf2",
    "crypto",
    "browser"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "webcrypto-crypt",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/c2fo-lab/webcrypto-crypt.git"
  },
  "scripts": {
    "clean": "rm -rf npm-debug.log ./dist ./examples/browser ./test/browser ./test/*.wcrypt",
    "postinstall": "node ./bin/browserify.js",
    "superclean": "rm -rf npm-debug.log ./dist ./examples/browser ./test/browser ./test/*.wcrypt ./node_modules",
    "test": "mocha --compilers js:babel-core/register --reporter spec"
  },
  "version": "0.1.18",
  "warnings": [
    {
      "code": "ENOTSUP",
      "required": {
        "node": "8",
        "npm": "4.5"
      },
      "pkgid": "webcrypto-crypt@0.1.18"
    }
  ]
}

},{}],42:[function(require,module,exports){
'use strict';

var binaryTestFile = './test/icon.png';
module.exports = {
    binary: {
        plaintext: binaryTestFile,
        encodings: {
            ciphertext: {
                b64: 'jheAmWPvapw7iGknZagv0Bolxn5ApPivLuboD0eSUIaOEwylaEhtVN0nsc+bOuI4teQrMBm2t7CwNty+pa7qcXmJDeJJClcoWEBaHuy3XINh8b2/cE3Ra3j+1YQkgo85zeptIy2KL6GIeorllipgb01ZQTQqrgnxXXe6P4HRVAmwRHdUkayEllqy+D+3c4ael4Rdt3FRV09a+MMpL+6Xn9xCpPQjWUCxOEOvgMUI1PTQ/GBOQdYf3hzdfWt2enMrx/6hIbKrf8hthQpN1unrNsgA41jgnkvs9GqiCUo/Cl1h7ZtAtMvn9j20jMdYix7r/ssFG7RBhcVt8H92jrXFHb+H3To/lXSbDa2YCpLiuKrY6/M4I4+UpV57Rsr/QZYG2BDnECpwUNCFTJTFAvSkcYgY/c195ZiOzLlSSUiseYGXyAoEgCAB7V+HqEVgXyF9anUAjHUvrQLCkGGUArYtONgHkJYQoFS9AbPlBM/GSl9XItH+WjJRGHqSDVUnCSo3x3g6MLbGIXgH4K3hDl0VLF0P4TV5jQzFmLSmhPkN8IZAZHdqekJfyV2plBuRNkOhWc477l6Gs+nwwDGAtfKuq4TvzLkJQVKUiVgxDlKCiZKaT030bEiIMeN2VHmbmvm6QdUF4QNo9Scz9/MVzREJeUtt+3nvWTbClJ3125uor2YdmjlXomxxLilGkJ3oN+4A2iYNkRo5l3CwBYQeQZ1NeByWNvwwlImEgBcskbCNeHr9/xx56yFvyi0CoBlQ4drqNAES312iV31zV3jKxO0MgLPFbrXffxfzgkI7D58mFa8KodXGhhiCaIevJIKNWkX7/o4mKjiQNPYmb1a/t+l41teO9psmix7M0sq6WvOO4nQYFz/VQ47cEToeaLrT4O8+y3u8pUWGddA3R9YumDWtBUr247urYOvqz4Fooon6tlh7f5K23SCk7uTX4Scx6vCg9sFzR2OeSoTxMzomwF4BvHMwIyKYoNZrH14XpyBPBzxZSkFC22OkOQjKcc2Z6CquduO/w5xxjlQo0a2D2uS+F0hUp9ExrtSsAh2enqPonIDjiao2R7cr2eD9z2Rv9rhcdmRN2GvNBahXzei6QYHhLwDsKcxlXRlWOttnizL4CIqtXPUc60h1yqc9D4faJM4pokegl4A8rOjRYCoWagmXjonF2Y/VilJR6crjrVP1d/4Iz2zwBdDq0v5j3S57ipmqACSO9xYC3aCuhGajFpVlvHS/3sfDdwLmrmH5FIkBYCczaHeUnFBRV1wb8+Zmvw+YKX/bA3LhW0KYkImv4CJXHAGgPaRpNTYphS0yb8ZZFGkNb/mq1rtuSXfhkoL6MlMyExCV/SRxNF46lFNv0xHUeaDvkLC2eHQhCFULJ4hL8Xa2QAPaKQWOebb2Mk+7gzYRB/zv/u2OVMqiDtd1+OsLH16UOVv7F2kUZ2iJzziuEm1xDRgObjuK/NpaI7qyxqx3CrpZldkF3KSSZge409a/ZX7OfptMWfznanK5ZWbi/8gF1h/ACv9x0xgKI+/R0yOXlY54nOnsrut78f9d6l25JWGiE6AeEAVropjcOW7l1FXWeTUb+B1WOo+/PXMZR/cShkno5+yyo0eE1puVu5S5xeaMzeCY0gotnVt7Eka/t2XlRd0i6TrpOD0D5JGmd41oLZXChWFFAec4i5/bHC8sAL6ZL1YUR2igWsy5H+/iIRjzc4grRA4mfgBkuBWAXnommbzykhcgINNmmVLMec2NUGQdGrty6KOSDHYNMVgXp1ZkNcD6yIkU8lDVZxTg00clPlMQf9WhgBueOyqCQboeoMNI3iM5yfYJ+Lz8dU5kKQkPMQfSn8CDWv48da/53mkx3RsLUdT6NmaEdrmB5blhrfv29LvX+97ZGGPdKpYvNjGOKmppEvFqHEccM+m9TfaLDryPbxnfj+UTlP+F8+sdufB9UWQ9tUm6pJWD8di+NBhbEuSiVEolU+E87eMT66J04E1RMfWZBtPKiR2FNG8GJVkzSuQ48MjV0tm6sgrfTUniWZjaKob7ozm7jbmy6fx2Q3wGMvUGQw7nHg8fcRzSbTX0c9o5Y1dy6CLCiIwMrWtKBAxnOf1QFfmUtHRoQVvmLv3GCXyKg9FVXyThei/L4XqxlyBAtn6MUfdZYsBV3HumWMSUeLdCrUAnF0rWTxlxROx8Z/eUqjWLx9UbnHW4T85WlLRMcys2hSZ8+XhuAXwfaEv04pDtrJCvNrxdGKymiDkXBGQMiOvMsEAPBERy5kpIuhRQTTKG6hMsyEwgPcF5ukUEIdYMclples0s5MHzQOCY21VbRFdsIfS7KGd/zQioni46GWnomG5LHwaaImeTn56TbkfNxo7Dptx7ufRbTJTZRvnBaNxamjgGaXq1BTWZSKS5uKQZ10j0n4t5EvEVhJRS1RALZRq14nt1SM1kZdxFicPA3xB5TxdBUMk3+Ks9KWXBOFd6Frjx+oL1lz6lAqZqTjmrJ4nvYluCDrTNGBQHj8yCIwzdp+n++buXsrhBr4tLoqIafOTHahTAK+fkmdTo5Z5JimESenlwiwAtggKS9T5cCWiTNlJfRLa7OTRwpykA8PWQcUbpSOWNmG7rS26dpkKz5+pQagsDQZNmlYWrukviDVAME6wzdHRnz/S1yXOO+9Volf9CerA7pmsyCCpZ2SAe9DRq/nRWTiHxYgYUYLGN23S8yGnhhon3TmRj7TUDqBUwPOxua8RPCfLYDdaYdiIf0OX1Uy3zspQN4sONeuAjJUXkTjehuiQQdXZzMYnNOutnv8HVFLmw+Ur9kd1U2lAF/aYWf0G1AayDDM49TLyMXw0Xeu92X/CWyNXWVzTlIchRuPwAFyRlR4AkWys4p2I5u6E1SJIBpIi4ZAK09+yVZPKS1p0EVVCNIr9DGpTZcmTTHuXQHtBo7rj+rTCnYftaBM7D8XT6ruiZQGUEdhSdWnFZhmRa6xjPBgfBkM1Fq64BT7YafPluImDbkfKl+34FTvhnVfqcqn29YgQFGC2KaW5C1G4GUGHgb+Ln7AXfPr4OmrHBmMkcmPEMTlETorMdHWLkRlDljrBOA5UTCO8qvmD3gqiTRUbXLIa+K7Fb4dGGZ6IxM9xukm729BkAHxMwoUepx/kak3HKP2jBqOo8AnKxgwV+Y4vhM80Q1gYo9QdZVDXg/xEhcaUPtjV0AztgvgePrIuTODts6wqQZuECshYG6yRzEDKliRm3DpIn00rby43GSa/9auMo6dSVDX4b2RjQPN4bR3XbNNz+BnFX6ChaB+raZ1P9ZiNSRkPuAggS0LB47elL0tkGcaJS80Pw5Eup/iyq1+FcTfKaouefWjhBml6JpYBPWJkcpeHYFq5goKG1jeyK99u0dgOftK9lbxCp94MvXGp/KmtZzCBSzVf5qG281Fo4Ell4m0YJYdJMDO6ikamNi2KuiE2ycf4hTa4ntAT5IdpuK1SIS6ieY4brKGhk/PmKVl9x/vARxEqSRm7fuQ2MUSyVN24=',
                hex: '8e17809963ef6a9c3b88692765a82fd01a25c67e40a4f8af2ee6e80f479250868e130ca568486d54dd27b1cf9b3ae238b5e42b3019b6b7b0b036dcbea5aeea7179890de2490a572858405a1eecb75c8361f1bdbf704dd16b78fed58424828f39cdea6d232d8a2fa1887a8ae5962a606f4d5941342aae09f15d77ba3f81d15409b044775491ac84965ab2f83fb773869e97845db77151574f5af8c3292fee979fdc42a4f4235940b13843af80c508d4f4d0fc604e41d61fde1cdd7d6b767a732bc7fea121b2ab7fc86d850a4dd6e9eb36c800e358e09e4becf46aa2094a3f0a5d61ed9b40b4cbe7f63db48cc7588b1eebfecb051bb44185c56df07f768eb5c51dbf87dd3a3f95749b0dad980a92e2b8aad8ebf338238f94a55e7b46caff419606d810e7102a7050d0854c94c502f4a4718818fdcd7de5988eccb9524948ac798197c80a04802001ed5f87a845605f217d6a75008c752fad02c290619402b62d38d807909610a054bd01b3e504cfc64a5f5722d1fe5a3251187a920d5527092a37c7783a30b6c6217807e0ade10e5d152c5d0fe135798d0cc598b4a684f90df0864064776a7a425fc95da9941b913643a159ce3bee5e86b3e9f0c03180b5f2aeab84efccb9094152948958310e528289929a4f4df46c488831e37654799b9af9ba41d505e10368f52733f7f315cd1109794b6dfb79ef5936c2949df5db9ba8af661d9a3957a26c712e2946909de837ee00da260d911a399770b005841e419d4d781c9636fc3094898480172c91b08d787afdff1c79eb216fca2d02a01950e1daea340112df5da2577d735778cac4ed0c80b3c56eb5df7f17f382423b0f9f2615af0aa1d5c68618826887af24828d5a45fbfe8e262a389034f6266f56bfb7e978d6d78ef69b268b1eccd2caba5af38ee27418173fd5438edc113a1e68bad3e0ef3ecb7bbca5458675d03747d62e9835ad054af6e3bbab60ebeacf8168a289fab6587b7f92b6dd20a4eee4d7e12731eaf0a0f6c17347639e4a84f1333a26c05e01bc7330232298a0d66b1f5e17a7204f073c594a4142db63a43908ca71cd99e82aae76e3bfc39c718e5428d1ad83dae4be174854a7d131aed4ac021d9e9ea3e89c80e389aa3647b72bd9e0fdcf646ff6b85c76644dd86bcd05a857cde8ba4181e12f00ec29cc655d19563adb678b32f8088aad5cf51ceb4875caa73d0f87da24ce29a247a097803cace8d1602a166a09978e89c5d98fd58a5251e9cae3ad53f577fe08cf6cf005d0ead2fe63dd2e7b8a99aa00248ef71602dda0ae8466a3169565bc74bfdec7c37702e6ae61f91489016027336877949c5051575c1bf3e666bf0f98297fdb0372e15b42989089afe022571c01a03da469353629852d326fc65914690d6ff9aad6bb6e4977e19282fa325332131095fd2471345e3a94536fd311d479a0ef90b0b678742108550b27884bf176b64003da29058e79b6f6324fbb83361107fceffeed8e54caa20ed775f8eb0b1f5e94395bfb176914676889cf38ae126d710d180e6e3b8afcda5a23bab2c6ac770aba5995d905dca4926607b8d3d6bf657ece7e9b4c59fce76a72b96566e2ffc805d61fc00aff71d3180a23efd1d32397958e789ce9ecaeeb7bf1ff5dea5db92561a213a01e10056ba298dc396ee5d455d679351bf81d563a8fbf3d731947f7128649e8e7ecb2a34784d69b95bb94b9c5e68ccde098d20a2d9d5b7b1246bfb765e545dd22e93ae9383d03e491a6778d682d95c285614501e7388b9fdb1c2f2c00be992f56144768a05accb91fefe22118f373882b440e267e0064b815805e7a2699bcf292172020d3669952cc79cd8d50641d1abb72e8a3920c760d315817a7566435c0fac88914f250d56714e0d347253e53107fd5a1801b9e3b2a8241ba1ea0c348de2339c9f609f8bcfc754e6429090f3107d29fc0835afe3c75aff9de6931dd1b0b51d4fa36668476b981e5b961adfbf6f4bbd7fbded91863dd2a962f36318e2a6a6912f16a1c471c33e9bd4df68b0ebc8f6f19df8fe51394ff85f3eb1db9f07d51643db549baa49583f1d8be34185b12e4a2544a2553e13cede313eba274e04d5131f59906d3ca891d85346f062559334ae438f0c8d5d2d9bab20adf4d49e25998da2a86fba339bb8db9b2e9fc76437c0632f506430ee71e0f1f711cd26d35f473da39635772e822c2888c0cad6b4a040c6739fd5015f994b47468415be62efdc6097c8a83d1555f24e17a2fcbe17ab1972040b67e8c51f75962c055dc7ba658c49478b742ad4027174ad64f197144ec7c67f794aa358bc7d51b9c75b84fce5694b44c732b3685267cf9786e017c1f684bf4e290edac90af36bc5d18aca688391704640c88ebccb0400f044472e64a48ba14504d3286ea132cc84c203dc179ba450421d60c725a657acd2ce4c1f340e098db555b44576c21f4bb28677fcd08a89e2e3a1969e8986e4b1f069a2267939f9e936e47cdc68ec3a6dc7bb9f45b4c94d946f9c168dc5a9a3806697ab505359948a4b9b8a419d748f49f8b7912f115849452d5100b651ab5e27b7548cd6465dc4589c3c0df10794f174150c937f8ab3d2965c138577a16b8f1fa82f5973ea502a66a4e39ab2789ef625b820eb4cd1814078fcc82230cdda7e9fef9bb97b2b841af8b4ba2a21a7ce4c76a14c02be7e499d4e8e59e498a61127a79708b002d820292f53e5c09689336525f44b6bb393470a72900f0f5907146e948e58d986eeb4b6e9da642b3e7ea506a0b034193669585abba4be20d500c13ac33747467cff4b5c9738efbd56895ff427ab03ba66b32082a59d9201ef4346afe74564e21f162061460b18ddb74bcc869e18689f74e6463ed3503a815303cec6e6bc44f09f2d80dd69876221fd0e5f5532df3b2940de2c38d7ae0232545e44e37a1ba24107576733189cd3aeb67bfc1d514b9b0f94afd91dd54da5005fda6167f41b501ac830cce3d4cbc8c5f0d177aef765ff096c8d5d65734e521c851b8fc001724654780245b2b38a76239bba135489201a488b86402b4f7ec9564f292d69d0455508d22bf431a94d97264d31ee5d01ed068eeb8fead30a761fb5a04cec3f174faaee89940650476149d5a715986645aeb18cf0607c190cd45abae014fb61a7cf96e2260db91f2a5fb7e054ef86755fa9caa7dbd620405182d8a696e42d46e065061e06fe2e7ec05df3ebe0e9ab1c198c91c98f10c4e5113a2b31d1d62e44650e58eb04e03951308ef2abe60f782a8934546d72c86be2bb15be1d18667a23133dc6e926ef6f419001f1330a147a9c7f91a9371ca3f68c1a8ea3c0272b183057e638be133cd10d60628f507595435e0ff112171a50fb63574033b60be078fac8b93383b6ceb0a9066e102b21606eb24731032a58919b70e9227d34adbcb8dc649affd6ae328e9d4950d7e1bd918d03cde1b4775db34dcfe067157e8285a07eada6753fd6623524643ee020812d0b078ede94bd2d90671a252f343f0e44ba9fe2caad7e15c4df29aa2e79f5a38419a5e89a5804f58991ca5e1d816ae60a0a1b58dec8af7dbb476039fb4af656f10a9f7832f5c6a7f2a6b59cc2052cd57f9a86dbcd45a381259789b460961d24c0ceea291a98d8b62ae884db271fe214dae27b404f921da6e2b54884ba89e6386eb286864fcf98a565f71fef011c44a92466edfb90d8c512c95376e'
            },
            plaintext: {
                b64: 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpMwidZAAAIRElEQVRYCZVXW2xcRxn+zjl71rtrr2+xk9ihQbZjCAqGtImcIKzSCCQaURRxqRSuKRUqSNA3EA+88ErVF8StEVIiIV4wESgRlkCJUBsrpFFSOUpvBNQ4dpxsYre2E99291yG75tzjrt1CW3H+nfmzPzz/99/mX/GDjY0Y4znOE40Nzd3tKur66mlpaWILN4Gtvf6NJ7nOdx7b3p6+uDw8PA/L1265O/duzd4r40gAEdMi4uLlzk2cRyHJPXvm6IoMvV6ParVaubq1av1M2fOfEoyBUJ9Y3MbPxrH1F3TN4V9ICJQhGEIAnDpgbCjo8Pv7Ox8fmxsbLc8sBHEfQFQt/UEw4EPQgJN8OpAD+Ty+Xy4Y8eOPEGMnzx58hMbQawD4BbX/Aw57lO83TgKLQCYmBLvQ5Ci/0EpfxgE8l6uXC6HO3fubOnu7j43Ojo6tBGERLwrye7ML51XDgSxCcPYmHdQxO9GCvndQGvVyCxXAzN544aZm70jMYZAgoWFBTM+Pr50/PjxISLH0aNHfcc8Ds/5E6IloLv0Nfcb+OiWvlpcieLdz369ubt3SxjUjeMxHAwF5C9LGmffnHBJWneScRzy4ARtuBV2wu/vR+/mTTaPXNcNmRe5K1euLF+7du3TR44cucJd5AUe8b7r/MXZ6bbDoz/yrcDyojxv4FO5ApORfKVczoLVOHbLnO8loA44xXZEgYfJhcOofmwfnJA5TYCe54YKy9TU1NLFixf3O28C2zoexetuH8qmgjpqtFGw/B4PXoGWM/76tkRwFrLmOJY3nJA/tNilGQ7JrbIn8mIL3Ac7Ydrewq3+5xFu7UWwuoJavQ4mZq2lpaVpYmLiF26xC99zPZTjSSoPkOdfzpJXofJJCpwmTdEr94BmmisqNwGtBaBY5/wcULhLWiMRSBPXCs3EGSB+IYLz0grKb5yD31REqVTEqVOnUKlUPB5PMCmdXLyMj4AJgAITUTWPRqxbrDgrRYvbgNs3gbML/G5oj3C8jWsB1xQasVuvpH2JAq9xKjcJ97MG+UJRSiHluZxiyIhFVW5bTjfQs+sCrKulvAd44SbM4UMwP30SaKHlams1OGdG4Yz+AdjDuFdvEQA3udyjvaKIYxoXVx3km/IoMll5BLF9+3YLoIneEgwHDBtK2kCSBWoSUHoAGLsB89tnED/5A7pbTG83c+DzcHfth/OTHwL7P8zKM5Xsz7wgVkZOacQTgKZ8HqwH69ZrLvGDii7DKW9bABKQo6V3bwBf7ER8+Amr3Hn1LJzLE1wk665dMLs/h/jxJ+Ce/xucib8C7e1AuJiAF5OMqJBXnlWjhwqFgi3V+lTZTgAokcUkANqk3t8EjN9E/KunEbd3w515He63PgMk+uEQX/TKS4gHHoJz4BCc3xDAYwQQEEAmZ5VyJkmcYC2yCs+/+CI2b96MwcHBpDZoeV25NmZAsuJYKlh5ZpamvMH1Qw8CX36IMed4Zsayo8SToaa92X71tzWpRsEEoNJ8+vRpzM7O2tnEA3J3pljWywVkhkuhRX0TuWY9Oou5hljx4qat7DinrbIu+eYRFLNOzx3OyQNpY/UBqzVGRkbQz+qYtVxmqJVk3c+NHivaWzSXR9ssrdklVHk+/8Vtb77Gs86e1pm1erK2wgSStbNXeUpYRW8x81jh0CF45GOsda2rZA8NDdljqHld2zkbc2u5OEl+GzffhTnwVdSP/RimaytMtYqw/+OIX3uV4NJ7iwJNZwdMrYZg5AsIX7kM//e/hvvM74CBTtaVeelIGuXKS7rW29raEDAUrIZ2LvGAwqAmIIUu4D8E8Nx3EOwehrNKP3KDaS4jamONt4zpj6xiadW86WVBOvgVFAjAtDIZ5wkglcsUtAmomM/PzdmT0NzcrEcLWcQkyiSv94wvrYvrtcTNVObQE2gkutCo+IQEWCVfpARQYy9HZYZRsTygMBw7dgx8plkuPljSEGQAMuV2majpOl2tunfkvvs1XvaIcxG8mB5RkzxbmhXTpAmAcmFgYAB87NpJAUpCkIbVeiFFzZuIlieu+3/KrSRroe7utKkcS2YmN5XDdw327NljS7HyIDmGYkoKchKG1FC9jcUgej8AYrqfb+gEQaY8NYZ6EVEOGdDT02NlCsC7PZAaYDu5LCVtzLK4kcXOMzROxmuLADkyo1IAOl6G8ZSMKnNIBikJdQz5ROEGeUDM6vWtpsJjk4DHTbHV84j9O4lWac0S1/mwSPZqf0p2IgmOvHnixAlcv34dvu9jbW0NOb739Ox6WzmTybaV24hyfCI0lfiSEjoJ2ZiIiWB5Is778Oq8B9RynM+M4lZ7UuQFLskLuobV2xA4JdouAJknzAzwKB3yx2+iXP8l6uXtvE4JSroz/aneRKIUePBXKyiefBZmRFpYFgVADCwJ2i9lEV2/b98+9PX16X+GJAnDAubtW0DHXSXW59XYRDRrEUrPPY2SneN8ZpFAyEkiVmd7jetiUtnuYN9Ga2oszTIqpBx6OGguGb7iOQF7D9D98crKirxgci+/jL8/3I+n3Fbk4nsUq+IsiwssRA/wxvHpQylvBKBkFwBd43pHWOLkKm853g8O10zAGtfGhUG4lU/uddqLRetkZf/8/DwrcR6rq6u+7Gn9dz9+Pvgwvo9WfkoRH8N8mKa9xgLBXqmggqTkDEl1Kq2zr2msnuvyhr4jumA5wPj00OI/vvTtuwNbt7CmJaHgKTD8/8C/cOHCjyjNtg/9GTgyfBCPFXucTUbKPGoTPo+U41iKbTKSX+fdgmCvd5/AhBzTI4ZjvtSd+pxZPHvaPXcY8Rh3XNcuUtYozPpt5r82F28DuCKYPgAAAABJRU5ErkJggg==',
                hex: '89504e470d0a1a0a0000000d4948445200000020000000200806000000737a7af40000000467414d410000b18f0bfc6105000000206348524d00007a26000080840000fa00000080e8000075300000ea6000003a98000017709cba513c000000097048597300000b1300000b1301009a9c180000015969545874584d4c3a636f6d2e61646f62652e786d7000000000003c783a786d706d65746120786d6c6e733a783d2261646f62653a6e733a6d6574612f2220783a786d70746b3d22584d5020436f726520352e342e30223e0a2020203c7264663a52444620786d6c6e733a7264663d22687474703a2f2f7777772e77332e6f72672f313939392f30322f32322d7264662d73796e7461782d6e7323223e0a2020202020203c7264663a4465736372697074696f6e207264663a61626f75743d22220a202020202020202020202020786d6c6e733a746966663d22687474703a2f2f6e732e61646f62652e636f6d2f746966662f312e302f223e0a2020202020202020203c746966663a4f7269656e746174696f6e3e313c2f746966663a4f7269656e746174696f6e3e0a2020202020203c2f7264663a4465736372697074696f6e3e0a2020203c2f7264663a5244463e0a3c2f783a786d706d6574613e0a4cc227590000084449444154580995575b6c5c4719fece397bd6bb6baf6fb193d8a141b663080a86b4899c20acd208241a511471a914ae29152a48d037100fbcf04ad517c4ad115222215e30112811964089501b2ba45152394a6f04d438769c6c62b7b613df76f75c86ef9b738ebb75096dc7fa77e6ccfcf3ffdf7f997fc60e3634638ce7384e34373777b4ababeba9a5a5a5882cde06b6f7fa349ee739dc7b6f7a7afae0f0f0f03f2f5dbae4efddbb3778af8d2000474c8b8b8b973936711c8724f5ef9ba22832f57a3daad56ae6ead5abf53367ce7c4a3205427d63731b3f1ac7d45dd337857d2022508461080270e981b0a3a3c3efecec7c7e6c6c6cb73cb011c47d0150b7f504c3810f42024df0ea400fe4f2f97cb863c78e3c418c9f3c79f2131b41ac03e016d7fc0c39ee53bcdd380a2d00989812ef4390a2ff41297f1804f25eae5c2e873b77ee6ce9eeee3e373a3a3ab4118444bc2bc9eecc2f9d570e04b109c3d8987750c4ef460af9dd406bd5c82c57033379e386999bbd2331864082858505333e3ebe74fcf8f12122c7d1a3477dc73c0ecff913a225a0bbf435f71bf8e896be5a5c89e2ddcf7ebdb9bb774b18d48de3311c0c05e42f4b1a67df9c70495a7792711cf2e0046db81576c2efef47efe64d368f5cd70d9917b92b57ae2c5fbb76edd3478e1cb9c25de4051ef1beebfcc5d9e9b6c3a33ff2adc0f2a23c6fe053b90293917ca55cce82d53876cb9cef25a00e38c576448187c985c3a87e6c1f9c90394d809ee7860acbd4d4d4d2c58b17f73b6f02db3a1ec5eb6e1fcaa6823a6ab451b0fc1e0f5e819633fefab6447016b2e63896379c903fb4d8a5190ec9adb227f2620bdc073b61dadec2adfee7116eed45b0ba825abd0e2666ada5a5a5696262e2176eb10bdf733d94e3492a0f90e75fce9257a1f2490a9c264dd12bf780669a2b2a3701ad05a058e7fc1c50b84b5a23114813d70acdc419207e2182f3d20aca6f9c83df5444a954c4a953a750a9543c1e4f30299d5cbc8c8f800980021351358f46ac5bac382b458bdb80db3781b30bfc6e688f70bc8d6b01d7141ab15bafa47d8902af712a3709f7b306f942514a21e5b99c62c88845556e5b4e37d0b3eb02acaba5bc0778e126cce143303f7d1268a1e56a6b35386746e18cfe01d8c3b8576f110037b9dca3bda288631a17571de49bf22832597904b17dfb760ba089de120c070c1b4ada4092056a12507a0018bb01f3db67103ff903ba5b4c6f3773e0f37077ed87f3931f02fb3fccca3395eccfbc2056464e69c41380a67c1eac07ebd66b2ef1838a2ec3296f5b001290a3a5776f005fec447cf809abdc79f52c9ccb135c24ebae5d30bb3f87f8f127e09eff1b9c89bf02eded40b8988017938ca890579e55a3870a85822dd5fa54d94e002891c52400daa4dedf048cdf44fcaba711b777c39d791deeb73e0324fae1105ff4ca4b88071e8273e0109cdf10c063041010402667957226499c602db20acfbff822366fde8cc1c1c1a43668795db9366640b2e2582a58796696a6bcc1f5430f025f7e8831e77866c6b2a3c493a1a6bdd97ef5b735a946c104a0d27cfaf469cccecedad9c4037277a658d6cb0564864ba1457d13b9663d3a8bb98658f1e2a6adec38a7adb22ef9e61114b34ecf1dcec9036963f501ab35464646d0cfea98b55c66a89564ddcf8d1e2bda5b349747db2cadd92554793effc56d6fbec6b3ce9ed699b57ab2b6c20492b5b357794a58456f31f358e1d02178e463ac75adab640f0d0dd963a8795ddb391b736bb938497e1b37df8539f055d48ffd18a66b2b4cb58ab0ffe3885f7b95e0d27b8b024d67074cad8660e40b085fb90cfff7bf86fbccef80814ed69579e9481ae5ca4bbad6dbdada103014ac86762ef180c2a02620852ee03f04f0dc7710ec1e86b34a3f7283692e236a638db78ce98fac6269d5bce965413af8151408c0b43219e7092095cb14b409a898cfcfcdd993d0dcdcac470b59c424ca24aff78c2fad8bebb5c4cd54e6d0136824bad0a8f8840458255fa40450632f47658651b13ca0301c3b760c7ca6592e3e58d210640032e57699a8e93a5dadba77e4befb355ef6887311bc981e51933c5b9a15d3a4098072616060007cecda49014a429086d57a2145cd9b889627aefb7fcaad246ba1eeeeb4a91c4b66263795c3770df6ecd9634bb1f2203986624a0a721286d450bd8dc5207a3f0062ba9f6fe80441a63c35867a11510e19d0d3d363650ac0bb3d901a603bb92c256dccb2b891c5ce33344ec66b8b003932a352003a5e86f1948c2a7348062909750cf944e1067940cceaf5ada6c2639380c74db1d5f388fd3b895669cd12d7f9b048f66a7f4a7622098ebc79e2c4095cbf7e1dbeef636d6d0d39bef7f4ec7a5b3993c9b695db88727c223495f892123a09d9988889607922cefbf0eabc07d4729ccf8ce2567b52e4052ec90bba86d5db103825da2e009927cc0cf0281df2c76fa25cff25eae5edbc4e094aba33fda9de44a21478f0572b289e7c1666445a581605400c2c09da2f65115dbf6fdf3ef4f5f5e97f862409c302e6ed5b40c75d25d6e7d5d844346b114acf3d8d929de37c669140c8492256677b8deb6252d9ee60df466b6a2ccd322aa41c7a38682e19bee239017b0fd0fdf1caca8abc60722fbf8cbf3fdc8fa7dc56e4e27b14abe22c8b0b2c440ff0c6f1e943296f04a06417005de37a4758e2e42a6f39de0f0ed74cc01ad7c68541b8954fee75da8b45eb6465fffcfc3c2b711eabababbeec69fd773f7e3ef830be8f567e4a111fc37c98a6bdc602c15ea9a082a4e40c49752aadb3af69ac9eebf286be23ba6039c0f8f4d0e23fbef4edbb035bb7b0a625a1e02930fcffc0bf70e1c28f28cdb60ffd1938327c108f157b9c4d46ca3c6a133e8f94e3588a6d32925fe7dd8260af779fc0841cd3238663bed49dfa9c593c7bda3d7718f118775cd72e52d628ccfa6de6bf36176f03b822983e0000000049454e44ae426082'
            }
        }
    },
    fixed: {
        plaintext: 'Now is the time for all good women to come to the aid of their cryptocurrency.',
        encodings: {
            ciphertext: {
                hex: '4928b9fe079650e253ed495e458d0ea27c4ab47e21c894af418f876b679645911f7d2cd1030f4f76f142910a7b116a31d5c44a595df59084dd42b4a1eadcca928ff07d6c266922dac2253408a599819d606fc009b9177b5723b36779a76d',
                hexAltHash: '2aa322b29da8cfbe3971bbb6a84004337962f26dcf2abd7cb0147562641af93ae501d3c0262d8eb19d51cd384f696f37459cc40292cc1ed70b5e8b3aa33706e8885ca22131c8d0ab8b983862b2b44ff28d3c7025392c6ae02754799be3a1',
                hexAltIter: '498d4cb91910d8890d3737979d719aeae4656ae9a2b9cd2026c7597a6b79b3f6dcacef86975adc66b2403e711064603c27e7ce218886e636a054b12c9eab74537846cc27c571fb77b238372ef378e279d16c825da7cd9039786aa91dc12c',
                hexAltLength: '4928b9fe079650e253ed495e458d0ea27c4ab47e21c894af418f876b679645911f7d2cd1030f4f76f142910a7b116a31d5c44a595df59084dd42b4a1eadcca928ff07d6c266922dac2253408a599819d606fc009b9177b5723b36779a76d',
                hexAltSeveral: '4c2f303ca3ae87c9d6f21972551477c8bac1d5a232f4f26eb22de79c4cce7f9adfd5754a8c92a511e447e9221420eb6bc682b04ef6bbd49916051dd7208653bdfd6c869e62bcf517ba2cd1f56e25a03d1fe842576f9ebef4dce970d2',
                hexAltTagLength: '4928b9fe079650e253ed495e458d0ea27c4ab47e21c894af418f876b679645911f7d2cd1030f4f76f142910a7b116a31d5c44a595df59084dd42b4a1eadcca928ff07d6c266922dac2253408a599819d606fc009b9177b5723b36779',
                hexAltUsages: '4928b9fe079650e253ed495e458d0ea27c4ab47e21c894af418f876b679645911f7d2cd1030f4f76f142910a7b116a31d5c44a595df59084dd42b4a1eadcca928ff07d6c266922dac2253408a599819d606fc009b9177b5723b36779a76d'
            }
        }
    },

    license: {
        hex: '57435259505430302e30312e3138323030303132383132385348412d353132313233343536373839303132313233343536373839303132333435363c57635279502b3e4a0e9afe228c13f355fb0c2026a304f26357af3928d0d8a745c9c83d77d01ddc39214aea66257c7cee4ad80d67587137908d581051b08d879f4ffca3f1cf848598ed21382f7832cd902f3c4bbfdf3d1b669491a59c22f11d661b4fa57df0fc56aaba4a182aeb46c4f214edcee40b039aa1384b5b4dd714cd6c70c201a28d4311bc1873109fa0859843acfb50d41ae7eace9847ab73424f474bf7973036eb9682c65cf0ba274e0ffb2911a4d3dd36dee6c5a4231c5cce4e9f4cdd797630475f17edd4a073a3e32fc60ac45c1b9f82b973c84bf848eecb6cdc9238bf175223100467e09213ba83faec2ee2d68c46920ee5fe915f1ca953ded438a02b30cae69e46e2c48f2a31dd27900abe9106cc86bfe6daa08a7d2f8fd7ea0e3e188ef414b60acd0ab95937614bd88e40c6d111aca97a9405a5d03baee1da9ef0101c1ce97581c49d4810842f0af01696ed03670c673a717350c53f6caf7b8f9e759205a02334d14acb8a1ce661fd56e9a24a9f9d6c5f166c95fe0e7d51482394095a35131520dc6e3b2aa4923c7849a9f4b24c0908225e15fd28769c15d08ba5ef82e4399cd3122a3e39321b149b4da08e3b9b6553bc1c9e3cf25382e880a4c065d3baf4a2a89edbe7935b2419d29f0569004d81888f8f1828d6dd55db3bb7167510beb9c2942d6031d51f4dc057aa51be4e75c516bf47b948c0207ca0d5f4fe004f6251fda7a6e16e249c1620e9529cd0eba75f4d5fab45dd413289a0dd7377ba4904a619495de980ddd5a898cc4b3617cd89c213dce5faf577fae2b8b7861d3629f67e2eebced308b84345c26cb5efec5c1b611c7fb87401f18e32911eee444a18fb1ee750f60b2e2603f4596409fbdd233e2a9e58e7701c1662a39d34fabff1c9ccfc8d676c731aed0c76d2a286d4d69e3e2534037746681b293f1faadd6e0a1dec8e16cbeecf5c39a3230afebc7fb03cd439932a6ca995ef2b94f46cac245bcdff8a7e703e34b61a18b05302076c458e6dc3dd9ec83701a33b1f64a5eec2ef6f468d4db6303387899ae67ed0b27b83cea1886f3390862e1b6f3fed58e5e9c19a1c406fd4cdfc424c842bf606e006ec29b93552ac293397877c12cc50177d5ee09943be3d2347dd4f5dc35e4db42fce96101f05d818b556f63b344961ce00cba2ca3cf405b66349e4ffc56c5370af563c9429dc7bca28210f498fb5efd84a707be29d169ecc3747076d22f16ca12faca2558bf66f7f70ab3d9d52f59577dfeb6cf47ab2ccfc3795ce02816a063172966a3b3afea448631825460ac9f77db62e18b9df284b27e95f676264bf41a0035a680a43ab64aa0c721aff5ba264e39ffd3b3f2aed849f3396bb824d87c1133672404952f0e5e11dd9b8498745d9c99ee05c2d4b9fa88c1ec02f6a0302bd31f903bcfb9387b4d0876ac21a2b888151f987b971b78be1311b0b3053bc379e766829b8f71478d496189a5ce271c499af03c402fb9be3d075505066a33fe3d79fcd8757428c11040dbad883813c57635279502b3e'
    },

    variable: {
        plaintext: '18      40,000     . 1606      1770,       , 1788 1 26         .      ,        . 1901 1 1,      .          . 1942       , 1948         . 1986           ,              .',
        encodings: {
            ciphertext: {
                hex: '367f225ad60fc8261b63ceba0c0cf722f1ba7bb2dd1c131c820c7597670db74896b0b08580b298f53ca35de98411f2ec2c08adbc19e1cfcecd06ec2f062aca1d5d0de6aec9e7d31890acc1fb3014e082ae4d56164ca14cc8288eed61f41717d249020590ec09c33627912b72a5c7f7593bf3e9d88c738b2ea12dc243fbdb018d58ee36db7a6a0a35be3416bf5ce01abe414fd22285b5d09f83757ee5626e61480ab03d3bc885c473d5955c4f14c31d6c2457a9cb85cc8c03f043a4fab9b7a25b0b207abe4c0f6ad76e9c0a846d67e736028b29d7262cf53506a750dccde9f58cb52510f72a837f1bd8641645c361dde565608f984c82477eec22e6d1521a56c42b0643cbdd549a7a433276eb532676655d55158fae4329015eabaa3e75f0728838d779e4c224d5276a8160018f6f59330bef351cca5f7e325072dbd944ac68968fd0c1f9696c5e72fe67e111308e9ea9f5b7f05bdeb0e39a6545e979cc3f99eb5be01b0ee26ede0f8c715f8fcd14e3c39b9f69fe9699ecd3e95a8894c1d8c4d98ef1f7c03b2ff0fcfa7a7040a50990c2a3d928e6fd7dd69115605a07279a162dfca9d5eeb0c6c09bd54432b36ad4cd46a855e633dd6c11c33c7da557353c26500a9d6474aba7f02a1af2d18fb567076d5f5f675219d7f1dd7ecafdab5bfb417ff0aae71684be261e21896282a31a423dae448219fe386c2a007bedfeffa207207c32316d18f4806c98715515425fd4844ec537ec70010324f0834ed7f05b91ff80a74b371d281600cef6e244677a5c425b196cac11b635526f9ff8f93aa9c1730a3a473a86f147ba157724b8d7aecff26d9f40695aa877901ee79fa044c629ef2aee524312843a75b22c165546824088e763b1d8fec6eefa41334a04375e72aed4ced58cb2af0e077d311a76f8efc5cd0e8ab4e28aee9a670daeb6d805fda9730571dcd403f9fe5c59b37081219c76cad5785881802306d248adf91f2f8adebdd79644e2b1059fa1bfb8e640e9babc2730dea542dfb6aa3d816857a3e96aa314c2c1f3247f2fd93f4ace0f45c72da3fc3843d8d7b5cc54d938e97d46f6f9b323b85b88ba4fde1b745ce92a802bc0f06cb891454d15b02a92b283b1853eb67085aae77eb3f1adfafd69951c50afb4f2be79c823e25d9789efafb9044269e403c8738982080c79bfa5d46cae4859f61fdb10c89fc1f1ed1c6f15efab904245b2f868d5fcaab6fff1c27be7094fec4712afdead50936fee9a2cfd3855911cc20b3c959d6103a56e92b48dca2db5f6822a5df1eae147467abee3041effd51d2788e9e5793cc4b494018a47bafcf0b5ac71dc17ffcb9c1ce37fa55d5f244890b77d296ec6286754e12d136192b3ecaf8524912df20372b378457c0c1e48bcdfee494f34ca0f41a6ccef05f37dba7e065874737a4e8168eec2445b87f93944997b7e3398a6c0429f71cf3aa993e4692abf8611f8b459e447a86c266ce2e07185e48fb1df8791684566e694ce92acc8dc9094236aac9cbe941637a6112a69a1aa79ee038f232d71639f4931737701d572f74ec6fcfb78ac5c8138739ac2d5e2489120ce5e0ddb29c223ae15840c735c793179b8be03ee0765dbfbc397cd9e5697760b23efce8f6afd4b614c4a526e3ec07ce3b9aa6ea7c85b4ee33c7924b346af4dda81f940fe503f3cee9a2d1ba4eaa83ba71ca52253f204177e9984141722a2307833cdbbd39742df29cae7b9f92db623d191547944a0b4fcdebcac3c72d567dd56fa4aca53eccf90d7e631aaa7555e0384df6829c1e928693f4950cbf0366cba2a8d9f7958aa90c1a1fa3a113ee2098dbcfc58dc943d25513068ae18be677cfa8f712a11e58189273f9c2229cfb0bd823e7f39253459849d4ac0b760fee30a88275b99bceea9224b2c20757b750ef439c748f2bb7eec86578362645cbdd25169a6e757b221ad01bfdf15a8aca3c95c2735ceca359cc4dcd354b74bfde021931ac7c9a36a14e76c1b'
            },
            ciphertextWithHeader: {
                hex: '57435259505430302e30312e3130323030303132383132385348412d353132313233343536373839303132313233343536373839303132333435363c57635279502b3e367f225ad60fc8261b63ceba0c0cf722f1ba7bb2dd1c131c820c7597670db74896b0b08580b298f53ca35de98411f2ec2c08adbc19e1cfcecd06ec2f062aca1d5d0de6aec9e7d31890acc1fb3014e082ae4d56164ca14cc8288eed61f41717d249020590ec09c33627912b72a5c7f7593bf3e9d88c738b2ea12dc243fbdb018d58ee36db7a6a0a35be3416bf5ce01abe414fd22285b5d09f83757ee5626e61480ab03d3bc885c473d5955c4f14c31d6c2457a9cb85cc8c03f043a4fab9b7a25b0b207abe4c0f6ad76e9c0a846d67e736028b29d7262cf53506a750dccde9f58cb52510f72a837f1bd8641645c361dde565608f984c82477eec22e6d1521a56c42b0643cbdd549a7a433276eb532676655d55158fae4329015eabaa3e75f0728838d779e4c224d5276a8160018f6f59330bef351cca5f7e325072dbd944ac68968fd0c1f9696c5e72fe67e111308e9ea9f5b7f05bdeb0e39a6545e979cc3f99eb5be01b0ee26ede0f8c715f8fcd14e3c39b9f69fe9699ecd3e95a8894c1d8c4d98ef1f7c03b2ff0fcfa7a7040a50990c2a3d928e6fd7dd69115605a07279a162dfca9d5eeb0c6c09bd54432b36ad4cd46a855e633dd6c11c33c7da557353c26500a9d6474aba7f02a1af2d18fb567076d5f5f675219d7f1dd7ecafdab5bfb417ff0aae71684be261e21896282a31a423dae448219fe386c2a007bedfeffa207207c32316d18f4806c98715515425fd4844ec537ec70010324f0834ed7f05b91ff80a74b371d281600cef6e244677a5c425b196cac11b635526f9ff8f93aa9c1730a3a473a86f147ba157724b8d7aecff26d9f40695aa877901ee79fa044c629ef2aee524312843a75b22c165546824088e763b1d8fec6eefa41334a04375e72aed4ced58cb2af0e077d311a76f8efc5cd0e8ab4e28aee9a670daeb6d805fda9730571dcd403f9fe5c59b37081219c76cad5785881802306d248adf91f2f8adebdd79644e2b1059fa1bfb8e640e9babc2730dea542dfb6aa3d816857a3e96aa314c2c1f3247f2fd93f4ace0f45c72da3fc3843d8d7b5cc54d938e97d46f6f9b323b85b88ba4fde1b745ce92a802bc0f06cb891454d15b02a92b283b1853eb67085aae77eb3f1adfafd69951c50afb4f2be79c823e25d9789efafb9044269e403c8738982080c79bfa5d46cae4859f61fdb10c89fc1f1ed1c6f15efab904245b2f868d5fcaab6fff1c27be7094fec4712afdead50936fee9a2cfd3855911cc20b3c959d6103a56e92b48dca2db5f6822a5df1eae147467abee3041effd51d2788e9e5793cc4b494018a47bafcf0b5ac71dc17ffcb9c1ce37fa55d5f244890b77d296ec6286754e12d136192b3ecaf8524912df20372b378457c0c1e48bcdfee494f34ca0f41a6ccef05f37dba7e065874737a4e8168eec2445b87f93944997b7e3398a6c0429f71cf3aa993e4692abf8611f8b459e447a86c266ce2e07185e48fb1df8791684566e694ce92acc8dc9094236aac9cbe941637a6112a69a1aa79ee038f232d71639f4931737701d572f74ec6fcfb78ac5c8138739ac2d5e2489120ce5e0ddb29c223ae15840c735c793179b8be03ee0765dbfbc397cd9e5697760b23efce8f6afd4b614c4a526e3ec07ce3b9aa6ea7c85b4ee33c7924b346af4dda81f940fe503f3cee9a2d1ba4eaa83ba71ca52253f204177e9984141722a2307833cdbbd39742df29cae7b9f92db623d191547944a0b4fcdebcac3c72d567dd56fa4aca53eccf90d7e631aaa7555e0384df6829c1e928693f4950cbf0366cba2a8d9f7958aa90c1a1fa3a113ee2098dbcfc58dc943d25513068ae18be677cfa8f712a11e58189273f9c2229cfb0bd823e7f39253459849d4ac0b760fee30a88275b99bceea9224b2c20757b750ef439c748f2bb7eec86578362645cbdd25169a6e757b221ad01bfdf15a8aca3c95c2735ceca359cc4dcd354b74bfde021931ac7c9a36a14e76c1b'
            }
        }
    }
};

},{}],43:[function(require,module,exports){
(function (Buffer){
'use strict';

var Config = require('../lib/config.json'),
    expect = require('expect'),
    mocks = new (require('./mocks.js'))(),
    transcoder = new (require('../lib/transcoder.js'))(),
    Wcrypt = require('../index.js');

var data = mocks.data,
    fixedCipher = data.fixed.encodings.ciphertext,
    fixedPlain = data.fixed.plaintext,
    testOptions = { material: {
        iv: mocks.iv,
        passphrase: mocks.passphrase,
        salt: mocks.salt
    } },
    variableCipher = data.variable.encodings.ciphertext,
    variablePlain = data.variable.plaintext,
    variableWithHeader = data.variable.encodings.ciphertextWithHeader;

describe("Decrypt", function () {

    it("Fails with no data", function (done) {
        var wcrypt = new Wcrypt.cipher(testOptions);
        wcrypt.rawDecrypt().catch(function (err) {
            done();
        });
    });

    it("Accepts valid tagLength override", function (done) {
        var options = {
            config: {
                crypto: {
                    tagLength: mocks.altTagLength
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltTagLength, 'hex')).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects invalid tagLength override", function (done) {
        var options = {
            config: {
                crypto: {
                    tagLength: mocks.altTagLengthInvalid
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltTagLength, 'hex')).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    it("Accepts valid length override", function (done) {
        var options = {
            config: {
                derive: {
                    length: mocks.altLength
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltLength, 'hex')).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects invalid length override", function (done) {
        var options = {
            config: {
                derive: {
                    length: mocks.altLengthInvalid
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltLength, 'hex')).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    it("Accepts valid hash override", function (done) {
        var options = {
            config: {
                derive: {
                    hash: mocks.altHash
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltHash, 'hex')).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects invalid hash override", function (done) {
        var options = {
            config: {
                derive: {
                    hash: mocks.altHashInvalid
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltHash, 'hex')).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    it("Accepts valid iterations override", function (done) {
        var options = {
            config: {
                derive: {
                    iterations: mocks.altIter
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltIter, 'hex')).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects invalid iterations override", function (done) {
        var options = {
            config: {
                derive: {
                    iterations: mocks.altIterInvalid
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltIter, 'hex')).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    it("Accepts valid usages override", function (done) {
        var options = {
            config: {
                crypto: {
                    usages: mocks.altUsagesDecrypt
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltUsages, 'hex')).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects invalid usages override", function (done) {
        var options = {
            config: {
                crypto: {
                    usages: mocks.altUsagesDecryptInvalid
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltUsages, 'hex')).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    it("Accepts several valid overrides", function (done) {
        var options = {
            config: {
                crypto: {
                    tagLength: mocks.altTagLength,
                    usages: mocks.altUsagesDecrypt
                },
                derive: {
                    hash: mocks.altHash,
                    iterations: mocks.altIter,
                    length: mocks.altLength
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltSeveral, 'hex')).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects several invalid overrides", function (done) {
        var options = {
            config: {
                crypto: {
                    tagLength: mocks.altTagLengthInvalid,
                    usages: mocks.altUsagesDecryptInvalid
                },
                derive: {
                    hash: mocks.altHashInvalid,
                    iterations: mocks.altIterInvalid,
                    length: mocks.altLengthInvalid
                }
            },
            material: {
                iv: mocks.iv,
                passphrase: mocks.passphrase,
                salt: mocks.salt
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawDecrypt(Buffer.from(fixedCipher.hexAltSeveral, 'hex')).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    describe("Fixed length UTF-8 string", function () {

        it("Fails with no passphrase", function (done) {
            var options = { material: {
                    iv: mocks.iv,
                    salt: mocks.salt
                } },
                wcrypt = new Wcrypt.cipher(options);
            wcrypt.rawDecrypt(Buffer.from(fixedCipher.hex, 'hex')).catch(function (err) {
                if (err.match(new RegExp(Config.err.passphrase))) {
                    done();
                } else {
                    done(err);
                }
            });
        });

        it("Accepts buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawDecrypt(Buffer.from(fixedCipher.hex, 'hex')).then(function (buf) {
                expect(buf).toExist();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawDecrypt(Buffer.from(fixedCipher.hex, 'hex')).then(function (buf) {
                expect(Buffer.isBuffer(buf)).toBeTruthy();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns expected buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawDecrypt(Buffer.from(fixedCipher.hex, 'hex')).then(function (buf) {
                expect(buf).toEqual(Buffer.from(fixedPlain, 'utf8'));
                done();
            }).catch(function (err) {
                done(err);
            });
        });
    });

    describe("Variable length UTF-8 string", function () {

        it("Fails with no passphrase", function (done) {
            var options = { material: {
                    iv: mocks.iv,
                    salt: mocks.salt
                } },
                wcrypt = new Wcrypt.cipher(options);
            wcrypt.rawDecrypt(Buffer.from(variableCipher.hex, 'hex')).catch(function (err) {
                if (err.match(new RegExp(Config.err.passphrase))) {
                    done();
                } else {
                    done(err);
                }
            });
        });

        it("Accepts buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawDecrypt(Buffer.from(variableCipher.hex, 'hex')).then(function (buf) {
                expect(buf).toExist();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawDecrypt(Buffer.from(variableCipher.hex, 'hex')).then(function (buf) {
                expect(Buffer.isBuffer(buf)).toBeTruthy();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns expected buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawDecrypt(Buffer.from(variableCipher.hex, 'hex')).then(function (buf) {
                expect(buf).toEqual(Buffer.from(variablePlain, 'utf8'));
                done();
            }).catch(function (err) {
                done(err);
            });
        });
    });

    describe("Binary data", function () {

        it("Fails with no passphrase", function (done) {
            var options = { material: {
                    iv: mocks.iv,
                    salt: mocks.salt
                } },
                wcrypt = new Wcrypt.cipher(options);
            wcrypt.rawDecrypt(mocks.png).catch(function (err) {
                if (err.match(new RegExp(Config.err.passphrase))) {
                    done();
                } else {
                    done(err);
                }
            });
        });

        it("Accepts buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawDecrypt(mocks.pngCipher).then(function (buf) {
                expect(buf).toExist();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawDecrypt(mocks.pngCipher).then(function (buf) {
                expect(Buffer.isBuffer(buf)).toBeTruthy();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns expected buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawDecrypt(mocks.pngCipher).then(function (buf) {
                var hash1, hash2;
                wcrypt.crypto.subtle.digest({ name: "SHA-256" }, transcoder.buf2ab(buf)).then(function (hash) {
                    hash1 = Buffer.from(hash).toString('hex');
                    hash2 = mocks.pngHash;
                    expect(hash1).toEqual(hash2);
                    try {
                        var dataURI = 'data:image/png;base64,' + buf.toString('base64');
                        var img = document.createElement('img');
                        console.log('Rendering decrypted image...');
                        img.src = dataURI;
                        img.title = 'Decrypted image';
                        document.getElementsByTagName('body')[0].appendChild(img);
                    } catch (err) {}
                    done();
                }).catch(function (err) {
                    done('Hash saved version: ' + err);
                });
            }).catch(function (err) {
                done('Encrypt: ' + err);
            });
        });
    });

    describe("Variants", function () {

        describe("decrypt", function () {

            it("Returns file signature", function (done) {
                var wcrypt = new Wcrypt.cipher(mocks.passphrase);
                wcrypt.decrypt(Buffer.from(variableWithHeader.hex, 'hex')).then(function (buf) {
                    expect(buf).toEqual(Buffer.from(variablePlain, 'utf8'));
                    done();
                }).catch(function (err) {
                    done(err);
                });
            });
        });
    });
});

}).call(this,require("buffer").Buffer)
},{"../index.js":38,"../lib/config.json":39,"../lib/transcoder.js":40,"./mocks.js":45,"buffer":6,"expect":15}],44:[function(require,module,exports){
(function (Buffer){
'use strict';

var Config = require('../lib/config.json'),
    expect = require('expect'),
    mocks = new (require('./mocks.js'))(),
    Package = require('../package.json'),
    transcoder = new (require('../lib/transcoder.js'))(),
    Wcrypt = require('../index.js');

var data = mocks.data,
    fixedCipher = data.fixed.encodings.ciphertext,
    fixedPlain = data.fixed.plaintext,
    testOptions = { material: {
        iv: mocks.iv,
        passphrase: mocks.passphrase,
        salt: mocks.salt
    } },
    variableCipher = data.variable.encodings.ciphertext,
    variablePlain = data.variable.plaintext;

describe("Encrypt", function () {

    it("Fails with no data", function (done) {
        var wcrypt = new Wcrypt.cipher(testOptions);
        wcrypt.rawEncrypt().catch(function (err) {
            done();
        });
    });

    it("Accepts valid tagLength override", function (done) {
        var options = {
            config: {
                crypto: {
                    tagLength: mocks.altTagLength
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects invalid tagLength override", function (done) {
        var options = {
            config: {
                crypto: {
                    tagLength: mocks.altTagLengthInvalid
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    it("Accepts valid length override", function (done) {
        var options = {
            config: {
                derive: {
                    length: mocks.altLength
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects invalid length override", function (done) {
        var options = {
            config: {
                derive: {
                    length: mocks.altLengthInvalid
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    it("Accepts valid hash override", function (done) {
        var options = {
            config: {
                derive: {
                    hash: mocks.altHash
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects invalid hash override", function (done) {
        var options = {
            config: {
                derive: {
                    hash: mocks.altHashInvalid
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    it("Accepts valid iterations override", function (done) {
        var options = {
            config: {
                derive: {
                    iterations: mocks.altIter
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects invalid iterations override", function (done) {
        var options = {
            config: {
                derive: {
                    iterations: mocks.altIterInvalid
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    it("Accepts valid usages override", function (done) {
        var options = {
            config: {
                crypto: {
                    usages: mocks.altUsagesEncrypt
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects invalid usages override", function (done) {
        var options = {
            config: {
                crypto: {
                    usages: mocks.altUsagesEncryptInvalid
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    it("Accepts several valid overrides", function (done) {
        var options = {
            config: {
                crypto: {
                    tagLength: mocks.altTagLength,
                    usages: mocks.altUsagesEncrypt
                },
                derive: {
                    hash: mocks.altHash,
                    iterations: mocks.altIter,
                    length: mocks.altLength
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done();
        }).catch(function (err) {
            done(err);
        });
    });

    it("Rejects several invalid overrides", function (done) {
        var options = {
            config: {
                crypto: {
                    tagLength: mocks.altTagLengthInvalid,
                    usages: mocks.altUsagesEncryptInvalid
                },
                derive: {
                    hash: mocks.altHashInvalid,
                    iterations: mocks.altIterInvalid,
                    length: mocks.altLengthInvalid
                }
            },
            material: {
                passphrase: mocks.passphrase
            }
        };
        var wcrypt = new Wcrypt.cipher(options);
        wcrypt.rawEncrypt(fixedPlain).then(function (data) {
            done('Invalid configuration accepted.');
        }).catch(function (err) {
            done();
        });
    });

    describe("Fixed length UTF-8 string", function () {

        it("Fails with no passphrase", function (done) {
            var options = { material: {
                    iv: mocks.iv,
                    salt: mocks.salt
                } },
                wcrypt = new Wcrypt.cipher(options);
            wcrypt.rawEncrypt(fixedPlain).catch(function (err) {
                if (err.match(new RegExp(Config.err.passphrase))) {
                    done();
                } else {
                    done(err);
                }
            });
        });

        it("Accepts buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawEncrypt(fixedPlain).then(function (buf) {
                expect(buf).toExist();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawEncrypt(fixedPlain).then(function (buf) {
                expect(Buffer.isBuffer(buf)).toBeTruthy();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns expected buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawEncrypt(fixedPlain).then(function (buf) {
                expect(buf).toEqual(Buffer.from(fixedCipher.hex, 'hex'));
                done();
            }).catch(function (err) {
                done(err);
            });
        });
    });

    describe("Variable length UTF-8 string", function () {

        it("Fails with no passphrase", function (done) {
            var options = { material: {
                    iv: mocks.iv,
                    salt: mocks.salt
                } },
                wcrypt = new Wcrypt.cipher(options);
            wcrypt.rawEncrypt(variablePlain).catch(function (err) {
                if (err.match(new RegExp(Config.err.passphrase))) {
                    done();
                } else {
                    done(err);
                }
            });
        });

        it("Accepts buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawEncrypt(variablePlain).then(function (buf) {
                expect(buf).toExist();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawEncrypt(variablePlain).then(function (buf) {
                expect(Buffer.isBuffer(buf)).toBeTruthy();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns expected buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawEncrypt(variablePlain).then(function (buf) {
                expect(buf).toEqual(Buffer.from(variableCipher.hex, 'hex'));
                done();
            }).catch(function (err) {
                done(err);
            });
        });
    });

    describe("Binary data", function () {

        it("Fails with no passphrase", function (done) {
            var options = { material: {
                    iv: mocks.iv,
                    salt: mocks.salt
                } },
                wcrypt = new Wcrypt.cipher(options);
            wcrypt.rawEncrypt(mocks.png).catch(function (err) {
                if (err.match(new RegExp(Config.err.passphrase))) {
                    done();
                } else {
                    done(err);
                }
            });
        });

        it("Accepts buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawEncrypt(mocks.png).then(function (buf) {
                expect(buf).toExist();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawEncrypt(mocks.png).then(function (buf) {
                expect(Buffer.isBuffer(buf)).toBeTruthy();
                done();
            }).catch(function (err) {
                done(err);
            });
        });

        it("Returns expected buffer", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            wcrypt.rawEncrypt(mocks.png).then(function (buf) {
                var hash1, hash2;
                wcrypt.crypto.subtle.digest({ name: "SHA-256" }, transcoder.buf2ab(buf)).then(function (hash) {
                    hash1 = Buffer.from(hash).toString('hex');
                    hash2 = mocks.pngCipherHash;
                    expect(hash1).toEqual(hash2);
                    done();
                }).catch(function (err) {
                    done('Hash saved version: ' + err);
                });
            }).catch(function (err) {
                done('Encrypt: ' + err);
            });
        });
    });

    describe("Variants", function () {

        describe("encrypt", function () {

            it("Returns file signature", function (done) {
                var wcrypt = new Wcrypt.cipher(testOptions);
                wcrypt.encrypt(variablePlain).then(function (buf) {
                    expect(buf.slice(0, 14)).toEqual(Buffer.from(Wcrypt.getSignature()));
                    done();
                }).catch(function (err) {
                    done(err);
                });
            });
        });

        describe("encryptDelimited", function () {
            it("Returns expected delimiter", function (done) {
                var wcrypt = new Wcrypt.cipher(testOptions);
                wcrypt.encryptDelimited(variablePlain).then(function (buf) {
                    expect(buf.slice(-8, buf.length)).toEqual(Buffer.from(wcrypt.getDelimiter()));
                    done();
                }).catch(function (err) {
                    done(err);
                });
            });
        });
    });

    describe("Version", function () {

        it("Returns expected value", function (done) {
            var wcrypt = new Wcrypt.cipher(testOptions);
            expect(Wcrypt.version).toEqual(Package.version);
            done();
        });
    });
});

}).call(this,require("buffer").Buffer)
},{"../index.js":38,"../lib/config.json":39,"../lib/transcoder.js":40,"../package.json":41,"./mocks.js":45,"buffer":6,"expect":15}],45:[function(require,module,exports){
(function (Buffer){
'use strict';

var data = require('./data.js'),
    fs = require('fs'),
    imageClear = data.binary.encodings.plaintext.b64,
    imageCipher = data.binary.encodings.ciphertext.b64,
    imageFile = data.binary.plaintext,
    toBuffer = require('blob-to-buffer'),
    Transcoder = require('../lib/transcoder.js'),
    transcoder = new Transcoder();

module.exports = function () {

    var mocks = {
        pngHash: '5795ae575f2a04c03ffd659dbe665cfad694f15f537b9f8b3673b3003a36da5d',
        pngCipherHash: '5041b67bf2aca626627a505943dc1dacc1ed278f659afe759de069b4fac0e346'
    };

    try {
        mocks.png = fs.readFileSync(imageFile);
        mocks.pngHash = '5795ae575f2a04c03ffd659dbe665cfad694f15f537b9f8b3673b3003a36da5d';
        mocks.pngCipher = Buffer.from(imageCipher, 'base64');
        mocks.pngCipherHash = '5041b67bf2aca626627a505943dc1dacc1ed278f659afe759de069b4fac0e346';
    } catch (err) {
        try {
            var xyz = Buffer.from(''); // hack
            mocks.png = new Blob([transcoder.b642uint8(imageClear)], { type: 'image/png' });
            toBuffer(mocks.png, function (err, buffer) {
                if (err) throw err;
                mocks.png = buffer;
                mocks.pngCipher = Buffer.from(imageCipher, 'base64');
            });
        } catch (err) {
            console.error('XERROR: ' + err);
        }
    }

    mocks.altHash = 'SHA-256';
    mocks.altHashInvalid = 'SHA-DOG';
    mocks.altIter = 10000;
    mocks.altIterInvalid = 'lorem ipsum';
    mocks.altLength = 128;
    mocks.altLengthInvalid = 999;
    mocks.altTagLength = 112;
    mocks.altTagLengthInvalid = 999;
    mocks.data = data;
    mocks.iv = transcoder.str2ab('123456789012');
    mocks.passphrase = 'testSecret';
    mocks.salt = transcoder.str2ab('1234567890123456');
    mocks.altUsagesDecrypt = ['decrypt'];
    mocks.altUsagesEncrypt = ['encrypt'];
    mocks.altUsagesEncryptInvalid = ['decrypt'];
    mocks.altUsagesDecryptInvalid = ['encrypt'];

    return mocks;
};

}).call(this,require("buffer").Buffer)
},{"../lib/transcoder.js":40,"./data.js":42,"blob-to-buffer":3,"buffer":6,"fs":5}]},{},[44,43]);
